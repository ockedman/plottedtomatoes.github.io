import {
  R,
  S,
  require_isNumber
} from "./chunk-732DGFZL.js";
import {
  H,
  I,
  W,
  z as z2
} from "./chunk-7AJ4HOP4.js";
import {
  B,
  C,
  Q,
  cn,
  j,
  ln,
  z
} from "./chunk-QYFNBIJB.js";
import {
  It,
  Ot,
  Sn,
  St,
  Ur,
  Wn,
  Xe,
  animated,
  gn,
  jn,
  k,
  linear,
  ordinal,
  pr,
  require_get,
  require_isPlainObject,
  require_isString,
  to,
  useTransition,
  w,
  wt,
  zt
} from "./chunk-XV5DIAUC.js";
import "./chunk-CY2I7XHN.js";
import "./chunk-NXESFFTV.js";
import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@nivo/swarmplot/dist/nivo-swarmplot.es.js
var e = __toESM(require_react());
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_isNumber = __toESM(require_isNumber());
var import_isPlainObject = __toESM(require_isPlainObject());
var import_isString = __toESM(require_isString());
var import_get = __toESM(require_get());

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x3 = +this._x.call(null, d), y3 = +this._y.call(null, d);
  return add(this.cover(x3, y3), x3, y3, d);
}
function add(tree, x3, y3, d) {
  if (isNaN(x3) || isNaN(y3)) return tree;
  var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j2;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (parent = node, !(node = node[i2 = bottom << 1 | right])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x3 === xp && y3 === yp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
  } while ((i2 = bottom << 1 | right) === (j2 = (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll(data) {
  var d, i2, n2 = data.length, x3, y3, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x3 = +this._x.call(null, d = data[i2])) || isNaN(y3 = +this._y.call(null, d))) continue;
    xz[i2] = x3;
    yz[i2] = y3;
    if (x3 < x0) x0 = x3;
    if (x3 > x1) x1 = x3;
    if (y3 < y0) y0 = y3;
    if (y3 > y1) y1 = y3;
  }
  if (x0 > x1 || y0 > y1) return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add(this, xz[i2], yz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x3, y3) {
  if (isNaN(x3 = +x3) || isNaN(y3 = +y3)) return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x3)) + 1;
    y1 = (y0 = Math.floor(y3)) + 1;
  } else {
    var z4 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1) {
      i2 = (y3 < y0) << 1 | x3 < x0;
      parent = new Array(4), parent[i2] = node, node = parent, z4 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z4, y1 = y0 + z4;
          break;
        case 1:
          x0 = x1 - z4, y1 = y0 + z4;
          break;
        case 2:
          x1 = x0 + z4, y0 = y1 - z4;
          break;
        case 3:
          x0 = x1 - z4, y0 = y1 - z4;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x3, y3, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i2;
  if (node) quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x3 - radius, y0 = y3 - radius;
    x32 = x3 + radius, y32 = y3 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0) continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i2 = (y3 >= ym) << 1 | x3 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x3 - d, y0 = y3 - d;
        x32 = x3 + d, y32 = y3 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x3 = +this._x.call(null, d)) || isNaN(y3 = +this._y.call(null, d))) return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x3, y3, xm, ym, right, bottom, i2, j2;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (!(parent = node, node = node[i2 = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3]) retainer = parent, j2 = i2;
  }
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j2] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x3, y3) {
  var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x3, y3, x0, y0, x1, y1) {
  this._x = x3;
  this._y = y3;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 4; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(4) });
        else node.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x(d) {
  return d.x + d.vx;
}
function y(d) {
  return d.y + d.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations = 1;
  if (typeof radius !== "function") radius = constant_default(radius == null ? 1 : +radius);
  function force() {
    var i2, n2 = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k2 = 0; k2 < iterations; ++k2) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r2 = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x3 = xi - data.x - data.vx, y3 = yi - data.y - data.vy, l2 = x3 * x3 + y3 * y3;
          if (l2 < r2 * r2) {
            if (x3 === 0) x3 = jiggle_default(random), l2 += x3 * x3;
            if (y3 === 0) y3 = jiggle_default(random), l2 += y3 * y3;
            l2 = (r2 - (l2 = Math.sqrt(l2))) / l2 * strength;
            node.vx += (x3 *= l2) * (r2 = (rj *= rj) / (ri2 + rj));
            node.vy += (y3 *= l2) * r2;
            data.vx -= x3 * (r2 = 1 - r2);
            data.vy -= y3 * r2;
          }
        }
        return;
      }
      return x0 > xi + r2 || x1 < xi - r2 || y0 > yi + r2 || y1 < yi - r2;
    }
  }
  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i2 = quad.r = 0; i2 < 4; ++i2) {
      if (quad[i2] && quad[i2].r > quad.r) {
        quad.r = quad[i2].r;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node;
    radii = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node = nodes[i2], radii[node.index] = +radius(node, i2, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _2 || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _2[t2] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    if (t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames(typename + "", _2), t2, i2 = -1, n2 = T.length;
    if (arguments.length < 2) {
      while (++i2 < n2) if ((t2 = (typename = T[i2]).type) && (t2 = get(_2[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i2 < n2) {
      if (t2 = (typename = T[i2]).type) _2[t2] = set(_2[t2], typename.name, callback);
      else if (callback == null) for (t2 in _2) _2[t2] = set(_2[t2], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _2 = this._;
    for (var t2 in _2) copy[t2] = _2[t2].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i2 = 0, n2 = type.length, c2; i2 < n2; ++i2) {
    if ((c2 = type[i2]).name === name) {
      return c2.value;
    }
  }
}
function set(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t2 = new Timer();
  t2.restart(callback, delay, time);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e2;
  while (t2) {
    if ((e2 = clockNow - t2._time) >= 0) t2._call.call(null, e2);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-force/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}

// node_modules/d3-force/src/simulation.js
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null) nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0) iterations = 1;
    for (var k2 = 0; k2 < iterations; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i2), angle = i2 * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function(x3, y3, radius) {
      var i2 = 0, n2 = nodes.length, dx, dy, d2, node, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x3 - node.x;
        dy = y3 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/x.js
function x_default2(x3) {
  var strength = constant_default(0.1), nodes, strengths, xz;
  if (typeof x3 !== "function") x3 = constant_default(x3 == null ? 0 : +x3);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vx += (xz[i2] - node.x) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    xz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(xz[i2] = +x3(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : x3;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y3) {
  var strength = constant_default(0.1), nodes, strengths, yz;
  if (typeof y3 !== "function") y3 = constant_default(y3 == null ? 0 : +y3);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vy += (yz[i2] - node.y) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    yz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(yz[i2] = +y3(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : y3;
  };
  return force;
}

// node_modules/@nivo/swarmplot/dist/nivo-swarmplot.es.js
function U() {
  return U = Object.assign ? Object.assign.bind() : function(e2) {
    for (var o2 = 1; o2 < arguments.length; o2++) {
      var i2 = arguments[o2];
      for (var t2 in i2) Object.prototype.hasOwnProperty.call(i2, t2) && (e2[t2] = i2[t2]);
    }
    return e2;
  }, U.apply(this, arguments);
}
function Z(e2, o2) {
  if (null == e2) return {};
  var i2, t2, n2 = {}, r2 = Object.keys(e2);
  for (t2 = 0; t2 < r2.length; t2++) i2 = r2[t2], o2.indexOf(i2) >= 0 || (n2[i2] = e2[i2]);
  return n2;
}
var $;
var _ = function(e2) {
  var o2 = e2.id, i2 = e2.formattedValue, t2 = e2.color;
  return (0, import_jsx_runtime.jsx)(w, { id: o2, value: i2, enableChip: true, color: t2 });
};
var ee = { id: "id", value: "value", valueScale: { type: "linear", min: 0, max: "auto" }, groupBy: "group", size: 6, spacing: 2, layout: "vertical", gap: 0, forceStrength: 1, simulationIterations: 120, colors: { scheme: "nivo" }, colorBy: "group", borderWidth: 0, borderColor: "rgba(0, 0, 0, 0)", layers: ["grid", "axes", "circles", "annotations", "mesh"], enableGridX: true, enableGridY: true, axisTop: {}, axisRight: {}, axisBottom: {}, axisLeft: {}, isInteractive: true, useMesh: false, debugMesh: false, tooltip: _, animate: true, motionConfig: "gentle", annotations: [], role: "img", pixelRatio: "undefined" != typeof window && null != ($ = window.devicePixelRatio) ? $ : 1 };
var oe = function(e2) {
  var o2 = e2.width, i2 = e2.height, t2 = e2.axis, n2 = e2.groups, r2 = e2.gap;
  if (!Array.isArray(n2) || 0 === n2.length) throw new Error("'groups' should be an array containing at least one item");
  var a3, l2 = n2.length;
  "x" === t2 ? a3 = (i2 - r2 * (l2 - 1)) / l2 : "y" === t2 && (a3 = (o2 - r2 * (l2 - 1)) / l2);
  var u = n2.map(function(e3, o3) {
    return o3 * (a3 + r2) + a3 / 2;
  });
  return ordinal(u).domain(n2);
};
var ie = function(e2) {
  var o2 = e2.width, i2 = e2.height, t2 = e2.axis, n2 = e2.getValue, r2 = e2.scale, a3 = e2.data.map(n2);
  if ("time" === r2.type) {
    var l2 = [{ data: a3.map(function(e3) {
      var o3;
      return { data: (o3 = { x: null, y: null }, o3[t2] = e3, o3) };
    }) }], u = ln(l2, t2, r2);
    return cn(r2, u, "x" === t2 ? o2 : i2, t2);
  }
  var s = Math.min.apply(Math, a3), c2 = Math.max.apply(Math, a3);
  return cn(r2, { all: a3, min: s, max: c2 }, "x" === t2 ? o2 : i2, t2);
};
var te = function(e2) {
  if ("function" == typeof e2) return e2;
  if ((0, import_isNumber.default)(e2)) return function() {
    return e2;
  };
  if ((0, import_isPlainObject.default)(e2)) {
    if (!(0, import_isString.default)(e2.key)) throw new Error("Size is invalid, key should be a string pointing to the property to use to determine node size");
    if (!Array.isArray(e2.values) || 2 !== e2.values.length) throw new Error("Size is invalid, values spec should be an array containing two values, min and max");
    if (!Array.isArray(e2.sizes) || 2 !== e2.sizes.length) throw new Error("Size is invalid, sizes spec should be an array containing two values, min and max");
    var o2 = linear().domain([e2.values[0], e2.values[1]]).range([e2.sizes[0], e2.sizes[1]]);
    return function(i2) {
      return o2((0, import_get.default)(i2, e2.key));
    };
  }
  throw new Error("Size is invalid, it should be either a function, a number or an object");
};
var ne = function(e2) {
  var o2, i2, t2 = e2.axis, n2 = e2.valueScale, r2 = e2.ordinalScale, a3 = e2.spacing, l2 = e2.forceStrength, u = collide_default(function(e3) {
    return e3.size / 2 + a3 / 2;
  });
  if ("x" === t2) o2 = x_default2(function(e3) {
    return n2(e3.value);
  }).strength(l2), i2 = y_default2(function(e3) {
    return r2(e3.group);
  });
  else {
    if ("y" !== t2) throw new Error("Invalid axis provided: " + t2);
    o2 = x_default2(function(e3) {
      return r2(e3.group);
    }), i2 = y_default2(function(e3) {
      return n2(e3.value);
    }).strength(l2);
  }
  return { x: o2, y: i2, collision: u };
};
var re = function(e2) {
  var o2, i2, t2 = e2.data, n2 = e2.getId, r2 = e2.layout, a3 = e2.getValue, l2 = e2.valueScale, u = e2.getGroup, s = e2.ordinalScale, c2 = e2.getSize, d = e2.forces, v = e2.simulationIterations, h = e2.valueScaleConfig, g = { horizontal: ["x", "y"], vertical: ["y", "x"] }, f = "time" === (i2 = h).type && "native" !== i2.format ? Q(i2) : function(e3) {
    return e3;
  }, p = t2.map(function(e3) {
    return { id: n2(e3), group: u(e3), value: f(a3(e3)), size: c2(e3), data: U({}, e3) };
  }), m2 = simulation_default(p).force("x", d.x).force("y", d.y).force("collide", d.collision).stop();
  return m2.tick(v), (o2 = {})[g[r2][0] + "Scale"] = l2, o2[g[r2][1] + "Scale"] = s, o2.nodes = m2.nodes(), o2;
};
var ae = function(e2) {
  var i2 = e2.width, t2 = e2.height, n2 = e2.axis, r2 = e2.getValue, a3 = e2.scale, l2 = e2.data;
  return (0, import_react.useMemo)(function() {
    return ie({ width: i2, height: t2, axis: n2, getValue: r2, scale: a3, data: l2 });
  }, [i2, t2, n2, r2, a3, l2]);
};
var le = function(e2) {
  var i2 = e2.width, t2 = e2.height, n2 = e2.axis, r2 = e2.groups, a3 = e2.gap;
  return (0, import_react.useMemo)(function() {
    return oe({ width: i2, height: t2, axis: n2, groups: r2, gap: a3 });
  }, [i2, t2, n2, r2, a3]);
};
var ue = function(e2) {
  var i2 = e2.axis, t2 = e2.valueScale, n2 = e2.ordinalScale, r2 = e2.spacing, a3 = e2.forceStrength;
  return (0, import_react.useMemo)(function() {
    return ne({ axis: i2, valueScale: t2, ordinalScale: n2, spacing: r2, forceStrength: a3 });
  }, [i2, t2, n2, r2, a3]);
};
var se = function(e2) {
  var i2 = e2.data, t2 = e2.width, n2 = e2.height, r2 = e2.id, a3 = e2.value, l2 = e2.valueFormat, c2 = e2.valueScale, d = e2.groups, v = e2.groupBy, h = e2.size, g = e2.spacing, f = e2.layout, p = e2.gap, m2 = e2.forceStrength, y3 = e2.simulationIterations, x3 = e2.colors, S2 = e2.colorBy, M = "horizontal" === f ? "x" : "y", b = Wn(r2), w2 = Wn(a3), C2 = Ot(l2), I2 = Wn(v), W2 = function(e3) {
    return (0, import_react.useMemo)(function() {
      return te(e3);
    }, [e3]);
  }(h), k2 = Wn(S2), z4 = pr(x3, k2), B3 = ae({ width: t2, height: n2, axis: M, getValue: w2, scale: c2, data: i2 }), L = le({ width: t2, height: n2, axis: M, groups: d, gap: p }), V = ue({ axis: M, valueScale: B3, ordinalScale: L, spacing: g, forceStrength: m2 }), T = (0, import_react.useMemo)(function() {
    return re({ data: i2, getId: b, layout: f, getValue: w2, valueScale: B3, getGroup: I2, ordinalScale: L, getSize: W2, forces: V, simulationIterations: y3, valueScaleConfig: c2 });
  }, [i2, b, f, w2, B3, I2, L, W2, V, y3, c2]), G2 = T.nodes, H3 = T.xScale, R3 = T.yScale;
  return { nodes: (0, import_react.useMemo)(function() {
    return G2.map(function(e3) {
      return U({}, e3, { formattedValue: C2(e3.value), color: z4(e3) });
    });
  }, [G2, C2, z4]), xScale: H3, yScale: R3, getColor: z4 };
};
var ce = function(e2) {
  return (0, import_react.useMemo)(function() {
    return "function" == typeof e2 ? e2 : function() {
      return e2;
    };
  }, [e2]);
};
var de = function(e2) {
  var o2 = e2.isInteractive, t2 = e2.onClick, n2 = e2.onMouseEnter, r2 = e2.onMouseLeave, a3 = e2.onMouseMove, l2 = e2.tooltip, u = k(), s = u.showTooltipFromEvent, c2 = u.hideTooltip;
  return { onMouseEnter: (0, import_react.useCallback)(function(e3, i2) {
    o2 && (s(l2(e3), i2), null == n2 || n2(e3, i2));
  }, [o2, n2, s, l2]), onMouseMove: (0, import_react.useCallback)(function(e3, i2) {
    o2 && (s(l2(e3), i2), null == a3 || a3(e3, i2));
  }, [o2, a3, s, l2]), onMouseLeave: (0, import_react.useCallback)(function(e3, i2) {
    o2 && (c2(), null == r2 || r2(e3, i2));
  }, [o2, c2, r2]), onClick: (0, import_react.useCallback)(function(e3, i2) {
    o2 && (null == t2 || t2(e3, i2));
  }, [o2, t2]) };
};
var ve = function(e2) {
  return { x: e2.x, y: e2.y };
};
var he = function(e2) {
  return { size: e2.size, width: e2.size, height: e2.size };
};
var ge = function(e2, o2) {
  return S({ data: e2, annotations: o2, getPosition: ve, getDimensions: he });
};
var fe = function(e2) {
  var i2 = e2.nodes, t2 = e2.xScale, n2 = e2.yScale, r2 = e2.innerWidth, a3 = e2.innerHeight, l2 = e2.outerWidth, u = e2.outerHeight, s = e2.margin;
  return (0, import_react.useMemo)(function() {
    return { nodes: i2, xScale: t2, yScale: n2, innerWidth: r2, innerHeight: a3, outerWidth: l2, outerHeight: u, margin: s };
  }, [i2, t2, n2, r2, a3, l2, u, s]);
};
var pe = function(i2) {
  var n2 = i2.nodes, r2 = i2.borderWidth, a3 = i2.borderColor, l2 = i2.component, u = i2.isInteractive, s = i2.onMouseEnter, v = i2.onMouseMove, h = i2.onMouseLeave, g = i2.onClick, f = i2.tooltip, p = k(), m2 = p.showTooltipFromEvent, y3 = p.hideTooltip, x3 = (0, import_react.useMemo)(function() {
    if (u) return function(e2, o2) {
      m2((0, import_react.createElement)(f, e2), o2), null == s || s(e2, o2);
    };
  }, [u, m2, f, s]), S2 = (0, import_react.useMemo)(function() {
    if (u) return function(e2, o2) {
      m2((0, import_react.createElement)(f, e2), o2), null == v || v(e2, o2);
    };
  }, [u, m2, f, v]), M = (0, import_react.useMemo)(function() {
    if (u) return function(e2, o2) {
      y3(), null == h || h(e2, o2);
    };
  }, [u, y3, h]), b = (0, import_react.useMemo)(function() {
    if (u) return function(e2, o2) {
      null == g || g(e2, o2);
    };
  }, [u, g]), w2 = Ur(), C2 = w2.animate, I2 = w2.config, W2 = zt(), E = ce(r2), V = Xe(a3, W2), T = (0, import_react.useMemo)(function() {
    return /* @__PURE__ */ function(e2) {
      return { enter: function(o2) {
        return { x: o2.x, y: o2.y, radius: 0, color: o2.color, borderColor: e2(o2), opacity: 0 };
      }, update: function(o2) {
        return { x: o2.x, y: o2.y, radius: o2.size / 2, color: o2.color, borderColor: e2(o2), opacity: 1 };
      }, leave: function(o2) {
        return { x: o2.x, y: o2.y, radius: 0, color: o2.color, borderColor: e2(o2), opacity: 0 };
      } };
    }(V);
  }, [V]), G2 = useTransition(n2, { keys: function(e2) {
    return e2.id;
  }, initial: T.update, from: T.enter, enter: T.update, update: T.update, leave: T.leave, config: I2, immediate: !C2 });
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: G2(function(o2, i3) {
    return e.createElement(l2, { key: i3.id, node: i3, style: U({}, o2, { radius: (t2 = o2.radius, to([t2], function(e2) {
      return Math.max(0, e2);
    })), borderWidth: E(i3) }), onMouseEnter: x3, onMouseMove: S2, onMouseLeave: M, onClick: b });
    var t2;
  }) });
};
var me = function(e2) {
  var o2 = e2.node, i2 = e2.style, t2 = e2.onMouseEnter, n2 = e2.onMouseMove, r2 = e2.onMouseLeave, a3 = e2.onClick;
  return (0, import_jsx_runtime.jsx)(animated.circle, { cx: i2.x, cy: i2.y, r: i2.radius, fill: i2.color, stroke: i2.borderColor, strokeWidth: i2.borderWidth, opacity: i2.opacity, onMouseEnter: function(e3) {
    return null == t2 ? void 0 : t2(o2, e3);
  }, onMouseMove: function(e3) {
    return null == n2 ? void 0 : n2(o2, e3);
  }, onMouseLeave: function(e3) {
    return null == r2 ? void 0 : r2(o2, e3);
  }, onClick: function(e3) {
    return null == a3 ? void 0 : a3(o2, e3);
  } }, o2.id);
};
var ye = function(e2) {
  var o2 = e2.nodes, i2 = e2.annotations, t2 = ge(o2, i2);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t2.map(function(e3, o3) {
    return (0, import_jsx_runtime.jsx)(R, U({}, e3), o3);
  }) });
};
var xe = ["nodes"];
var Se = ["theme", "isInteractive", "animate", "motionConfig", "renderWrapper"];
var Me = function(e2) {
  var o2 = e2.data, i2 = e2.width, r2 = e2.height, a3 = e2.margin, l2 = e2.id, u = void 0 === l2 ? ee.id : l2, s = e2.value, c2 = void 0 === s ? ee.value : s, d = e2.valueScale, v = void 0 === d ? ee.valueScale : d, f = e2.valueFormat, p = e2.groups, m2 = e2.groupBy, S2 = void 0 === m2 ? ee.groupBy : m2, M = e2.size, w2 = void 0 === M ? ee.size : M, C2 = e2.forceStrength, I2 = void 0 === C2 ? ee.forceStrength : C2, W2 = e2.simulationIterations, k2 = void 0 === W2 ? ee.simulationIterations : W2, B3 = e2.colors, E = void 0 === B3 ? ee.colors : B3, L = e2.colorBy, V = void 0 === L ? ee.colorBy : L, T = e2.borderColor, G2 = void 0 === T ? ee.borderColor : T, H3 = e2.borderWidth, R3 = void 0 === H3 ? ee.borderWidth : H3, F2 = e2.layout, j2 = void 0 === F2 ? ee.layout : F2, O = e2.spacing, A = void 0 === O ? ee.spacing : O, P = e2.gap, X = void 0 === P ? ee.gap : P, Y = e2.layers, D = void 0 === Y ? ee.layers : Y, N = e2.circleComponent, q = void 0 === N ? me : N, J = e2.useMesh, K = void 0 === J ? ee.useMesh : J, Q2 = e2.debugMesh, U2 = void 0 === Q2 ? ee.debugMesh : Q2, $2 = e2.enableGridX, _2 = void 0 === $2 ? ee.enableGridX : $2, oe2 = e2.gridXValues, ie2 = e2.enableGridY, te2 = void 0 === ie2 ? ee.enableGridY : ie2, ne2 = e2.gridYValues, re2 = e2.axisTop, ae2 = void 0 === re2 ? ee.axisTop : re2, le2 = e2.axisRight, ue2 = void 0 === le2 ? ee.axisRight : le2, ce2 = e2.axisBottom, ve2 = void 0 === ce2 ? ee.axisBottom : ce2, he2 = e2.axisLeft, ge2 = void 0 === he2 ? ee.axisLeft : he2, Se2 = e2.isInteractive, Me2 = e2.onMouseEnter, be2 = e2.onMouseMove, we2 = e2.onMouseLeave, Ce2 = e2.onClick, Ie2 = e2.tooltip, We2 = void 0 === Ie2 ? ee.tooltip : Ie2, ke2 = e2.annotations, ze2 = void 0 === ke2 ? ee.annotations : ke2, Be2 = e2.role, Ee = void 0 === Be2 ? ee.role : Be2, Le = wt(i2, r2, a3), Ve = Le.outerWidth, Te = Le.outerHeight, Ge = Le.margin, He = Le.innerWidth, Re = Le.innerHeight, Fe = se({ width: He, height: Re, data: o2, id: u, value: c2, valueFormat: f, valueScale: v, groups: p, groupBy: S2, size: w2, spacing: A, layout: j2, gap: X, colors: E, colorBy: V, forceStrength: I2, simulationIterations: k2 }), je = Fe.nodes, Oe = Z(Fe, xe), Ae = Oe.xScale, Pe = Oe.yScale, Xe2 = de({ isInteractive: Se2, onClick: Ce2, onMouseEnter: Me2, onMouseLeave: we2, onMouseMove: be2, tooltip: We2 }), Ye = { grid: null, axes: null, circles: null, annotations: null, mesh: null };
  D.includes("grid") && (Ye.grid = (0, import_jsx_runtime.jsx)(C, { width: He, height: Re, xScale: _2 ? Ae : null, xValues: oe2, yScale: te2 ? Pe : null, yValues: ne2 }, "grid")), D.includes("axes") && (Ye.axes = (0, import_jsx_runtime.jsx)(B, { xScale: Ae, yScale: Pe, width: He, height: Re, top: null != ae2 ? ae2 : void 0, right: null != ue2 ? ue2 : void 0, bottom: null != ve2 ? ve2 : void 0, left: null != ge2 ? ge2 : void 0 }, "axes")), D.includes("circles") && (Ye.circles = (0, import_jsx_runtime.jsx)(pe, { nodes: je, borderWidth: R3, borderColor: G2, isInteractive: Se2, tooltip: We2, component: q, onMouseEnter: Me2, onMouseMove: be2, onMouseLeave: we2, onClick: Ce2 }, "circles")), D.includes("annotations") && (Ye.annotations = (0, import_jsx_runtime.jsx)(ye, { nodes: je, annotations: ze2 }, "annotations")), Se2 && K && (Ye.mesh = (0, import_jsx_runtime.jsx)(I, { nodes: je, width: He, height: Re, onMouseEnter: Xe2.onMouseEnter, onMouseMove: Xe2.onMouseMove, onMouseLeave: Xe2.onMouseLeave, onClick: Xe2.onClick, debug: U2 }, "mesh"));
  var De = fe({ nodes: je, xScale: Ae, yScale: Pe, innerWidth: He, innerHeight: Re, outerWidth: Ve, outerHeight: Te, margin: Ge });
  return (0, import_jsx_runtime.jsx)(gn, { width: Ve, height: Te, margin: Ge, role: Ee, children: D.map(function(e3, o3) {
    return void 0 !== Ye[e3] ? Ye[e3] : "function" == typeof e3 ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(e3, De) }, o3) : null;
  }) });
};
var be = function(e2) {
  var o2 = e2.theme, i2 = e2.isInteractive, t2 = void 0 === i2 ? ee.isInteractive : i2, n2 = e2.animate, r2 = void 0 === n2 ? ee.animate : n2, a3 = e2.motionConfig, l2 = void 0 === a3 ? ee.motionConfig : a3, u = e2.renderWrapper, s = Z(e2, Se);
  return (0, import_jsx_runtime.jsx)(St, { isInteractive: t2, animate: r2, motionConfig: l2, theme: o2, renderWrapper: u, children: (0, import_jsx_runtime.jsx)(Me, U({ isInteractive: t2 }, s)) });
};
var we = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(o2) {
    var i2 = o2.width, t2 = o2.height;
    return (0, import_jsx_runtime.jsx)(be, U({ width: i2, height: t2 }, e2));
  } });
};
var Ce = ["nodes"];
var Ie = ["theme", "isInteractive", "animate", "motionConfig", "renderWrapper"];
var We = function(e2, o2) {
  var i2 = o2.node, t2 = o2.getBorderWidth, n2 = o2.getBorderColor, r2 = t2(i2);
  r2 > 0 && (e2.strokeStyle = n2(i2), e2.lineWidth = r2), e2.beginPath(), e2.arc(i2.x, i2.y, i2.size / 2, 0, 2 * Math.PI), e2.fillStyle = i2.color, e2.fill(), r2 > 0 && e2.stroke();
};
var ke = function(e2) {
  var o2 = e2.data, n2 = e2.width, u = e2.height, s = e2.margin, c2 = e2.id, v = void 0 === c2 ? ee.id : c2, g = e2.value, f = void 0 === g ? ee.value : g, y3 = e2.valueFormat, x3 = e2.valueScale, b = void 0 === x3 ? ee.valueScale : x3, W2 = e2.groups, B3 = e2.groupBy, E = void 0 === B3 ? ee.groupBy : B3, V = e2.size, T = void 0 === V ? ee.size : V, H3 = e2.forceStrength, R3 = void 0 === H3 ? ee.forceStrength : H3, F2 = e2.simulationIterations, j2 = void 0 === F2 ? ee.simulationIterations : F2, O = e2.colors, A = void 0 === O ? ee.colors : O, P = e2.colorBy, X = void 0 === P ? ee.colorBy : P, Y = e2.borderColor, D = void 0 === Y ? ee.borderColor : Y, N = e2.layout, q = void 0 === N ? ee.layout : N, J = e2.spacing, K = void 0 === J ? ee.spacing : J, Q2 = e2.gap, U2 = void 0 === Q2 ? ee.gap : Q2, $2 = e2.layers, _2 = void 0 === $2 ? ee.layers : $2, oe2 = e2.renderCircle, ie2 = void 0 === oe2 ? We : oe2, te2 = e2.debugMesh, ne2 = void 0 === te2 ? ee.debugMesh : te2, re2 = e2.enableGridX, ae2 = e2.gridXValues, le2 = e2.enableGridY, ue2 = e2.gridYValues, ce2 = e2.axisTop, de2 = void 0 === ce2 ? ee.axisTop : ce2, ve2 = e2.axisRight, he2 = void 0 === ve2 ? ee.axisRight : ve2, ge2 = e2.axisBottom, fe2 = void 0 === ge2 ? ee.axisBottom : ge2, pe2 = e2.axisLeft, me2 = void 0 === pe2 ? ee.axisLeft : pe2, ye2 = e2.isInteractive, xe2 = e2.onMouseMove, Se2 = e2.onClick, Me2 = e2.tooltip, be2 = void 0 === Me2 ? ee.tooltip : Me2, we2 = e2.role, Ie2 = void 0 === we2 ? ee.role : we2, ke2 = e2.pixelRatio, ze2 = void 0 === ke2 ? ee.pixelRatio : ke2, Be2 = (0, import_react.useRef)(null), Ee = zt(), Le = (0, import_react.useState)(null), Ve = Le[0], Te = Le[1], Ge = wt(n2, u, s), He = Ge.outerWidth, Re = Ge.outerHeight, Fe = Ge.margin, je = Ge.innerWidth, Oe = Ge.innerHeight, Ae = se({ width: je, height: Oe, data: o2, id: v, value: f, valueFormat: y3, valueScale: b, groups: W2, groupBy: E, size: T, spacing: K, layout: q, gap: U2, colors: A, colorBy: X, forceStrength: R3, simulationIterations: j2 }), Pe = Ae.nodes, Xe2 = Z(Ae, Ce), Ye = Xe2.xScale, De = Xe2.yScale, Ne = W({ points: Pe, width: je, height: Oe, debug: ne2 }), qe = Ne.delaunay, Je = Ne.voronoi, Ke = Xe(D, Ee), Qe = function() {
    return 1;
  };
  (0, import_react.useEffect)(function() {
    if (Be2.current) {
      Be2.current.width = He * ze2, Be2.current.height = Re * ze2;
      var e3 = Be2.current.getContext("2d");
      e3 && (e3.scale(ze2, ze2), e3.fillStyle = Ee.background, e3.fillRect(0, 0, He, Re), e3.save(), e3.translate(Fe.left, Fe.top), _2.forEach(function(o3) {
        "grid" === o3 && (0, import_isNumber.default)(Ee.grid.line.strokeWidth) && Ee.grid.line.strokeWidth > 0 && (e3.lineWidth = Ee.grid.line.strokeWidth, e3.strokeStyle = Ee.grid.line.stroke, re2 && z(e3, { width: je, height: Oe, scale: Ye, axis: "x", values: ae2 }), le2 && z(e3, { width: je, height: Oe, scale: De, axis: "y", values: ue2 })), "axes" === o3 && j(e3, { xScale: Ye, yScale: De, width: je, height: Oe, top: de2, right: he2, bottom: fe2, left: me2, theme: Ee }), "circles" === o3 && Pe.forEach(function(o4) {
          ie2(e3, { node: o4, getBorderWidth: Qe, getBorderColor: Ke });
        }), "mesh" === o3 && ne2 && Je && (z2(e3, Je), Ve && H(e3, Je, Ve.index));
      }));
    }
  }, [Be2, He, Re, je, Oe, ze2, Fe, Ee, _2, Ye, De, re2, ae2, le2, ue2, de2, he2, fe2, me2, Je, ne2, Ve, Pe, ie2, Qe, Ke]);
  var Ue = (0, import_react.useCallback)(function(e3) {
    if (!Be2.current) return null;
    var o3 = Sn(Be2.current, e3), i2 = o3[0], t2 = o3[1];
    if (!jn(Fe.left, Fe.top, je, Oe, i2, t2)) return null;
    var n3 = qe.find(i2 - Fe.left, t2 - Fe.top);
    return Pe[n3];
  }, [Be2, Fe, je, Oe, qe, Pe]), Ze = k(), $e = Ze.showTooltipFromEvent, _e = Ze.hideTooltip, eo = (0, import_react.useCallback)(function(e3, o3) {
    $e((0, import_react.createElement)(be2, e3), o3);
  }, [$e, be2]), oo = (0, import_react.useCallback)(function(e3) {
    var o3 = Ue(e3);
    Te(o3), o3 ? (null == xe2 || xe2(o3, e3), eo(o3, e3)) : _e();
  }, [Ue, Te, xe2, eo, _e]), io = (0, import_react.useCallback)(function() {
    _e(), Te(null);
  }, [_e, Te]), to2 = (0, import_react.useCallback)(function(e3) {
    var o3 = Ue(e3);
    o3 && (null == Se2 || Se2(o3, e3));
  }, [Ue, Se2]);
  return (0, import_jsx_runtime.jsx)("canvas", { ref: Be2, width: He * ze2, height: Re * ze2, style: { width: He, height: Re, cursor: ye2 ? "auto" : "normal" }, role: Ie2, onMouseEnter: ye2 ? oo : void 0, onMouseMove: ye2 ? oo : void 0, onMouseLeave: ye2 ? io : void 0, onClick: ye2 ? to2 : void 0 });
};
var ze = function(e2) {
  var o2 = e2.theme, i2 = e2.isInteractive, t2 = void 0 === i2 ? ee.isInteractive : i2, n2 = e2.animate, r2 = void 0 === n2 ? ee.animate : n2, a3 = e2.motionConfig, l2 = void 0 === a3 ? ee.motionConfig : a3, u = e2.renderWrapper, s = Z(e2, Ie);
  return (0, import_jsx_runtime.jsx)(St, { isInteractive: t2, animate: r2, motionConfig: l2, theme: o2, renderWrapper: u, children: (0, import_jsx_runtime.jsx)(ke, U({ isInteractive: t2 }, s)) });
};
var Be = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(o2) {
    var i2 = o2.width, t2 = o2.height;
    return (0, import_jsx_runtime.jsx)(ze, U({ width: i2, height: t2 }, e2));
  } });
};
export {
  ke as InnerSwarmPlotCanvas,
  we as ResponsiveSwarmPlot,
  Be as ResponsiveSwarmPlotCanvas,
  be as SwarmPlot,
  ze as SwarmPlotCanvas,
  _ as SwarmPlotTooltip,
  ne as computeForces,
  re as computeNodes,
  oe as computeOrdinalScale,
  ie as computeValueScale,
  ee as defaultProps,
  te as getSizeGenerator,
  We as renderCircleDefault,
  ce as useBorderWidth,
  ue as useForces,
  de as useNodeMouseHandlers,
  le as useOrdinalScale,
  se as useSwarmPlot,
  ge as useSwarmPlotAnnotations,
  fe as useSwarmPlotLayerContext,
  ae as useValueScale
};
//# sourceMappingURL=@nivo_swarmplot.js.map
