import {
  O
} from "./chunk-Q4AYEMRE.js";
import {
  C,
  Fr,
  Ht,
  In,
  It,
  Jt,
  Kt,
  Ot,
  St,
  Ur,
  We,
  Wn,
  Xe,
  animated,
  arc_default,
  bt,
  g,
  gn,
  k,
  lineRadial_default,
  linear,
  linearClosed_default,
  pr,
  to,
  useSpring,
  useSprings,
  vn,
  wt,
  zt
} from "./chunk-XV5DIAUC.js";
import "./chunk-CY2I7XHN.js";
import "./chunk-NXESFFTV.js";
import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@nivo/radar/dist/nivo-radar.es.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function z() {
  return z = Object.assign ? Object.assign.bind() : function(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = arguments[r2];
      for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
    }
    return e2;
  }, z.apply(this, arguments);
}
function j(e2, r2) {
  if (null == e2) return {};
  var t2, n2, o2 = {}, i2 = Object.keys(e2);
  for (n2 = 0; n2 < i2.length; n2++) t2 = i2[n2], r2.indexOf(t2) >= 0 || (o2[t2] = e2[t2]);
  return o2;
}
var T = function(r2) {
  var t2, n2 = r2.data, o2 = r2.item, i2 = r2.colorByKey, u = r2.fillByKey, c = r2.radiusScale, s = r2.rotation, f = r2.angleStep, m = r2.curveFactory, g2 = r2.borderWidth, v = r2.borderColor, y = r2.fillOpacity, h = r2.blendMode, p = zt(), b = Xe(v, p), x = (0, import_react.useMemo)(function() {
    return lineRadial_default().radius(function(e2) {
      return c(e2);
    }).angle(function(e2, r3) {
      return s + r3 * f;
    }).curve(m);
  }, [c, s, f, m]), k2 = Ur(), S = k2.animate, C2 = k2.config, I = Fr(x(n2.map(function(e2) {
    return e2[o2];
  }))), M = useSpring({ fill: i2[o2], stroke: b({ key: o2, color: i2[o2] }), config: C2, immediate: !S }), K = null != (t2 = u[o2]) ? t2 : M.fill;
  return (0, import_jsx_runtime.jsx)(animated.path, { d: I, fill: K, fillOpacity: y, stroke: M.stroke, strokeWidth: g2, style: { mixBlendMode: h } }, o2);
};
var E = function(e2) {
  var t2 = e2.radius, n2 = e2.angles, o2 = e2.indices, i2 = e2.label, a = e2.labelOffset, d = Ur(), s = d.animate, f = d.config, m = o2.map(function(e3, r2) {
    var o3, i3, l = Jt(n2[r2], t2 + a), d2 = (o3 = n2[r2], (i3 = Kt(o3) + 90) <= 10 || i3 >= 350 || i3 >= 170 && i3 <= 190 ? "middle" : i3 > 180 ? "end" : "start");
    return z({ id: e3, angle: Kt(n2[r2]), anchor: d2 }, l);
  }), g2 = useSprings(m.length, m.map(function(e3) {
    return { transform: "translate(" + e3.x + ", " + e3.y + ")", config: f, immediate: !s };
  }));
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: g2.map(function(e3, t3) {
    var n3 = m[t3];
    return (0, import_react.createElement)(i2, { key: n3.id, id: n3.id, anchor: n3.anchor, angle: n3.angle, x: n3.x, y: n3.y, animated: e3 });
  }) });
};
var H = ["shape"];
var G = (0, import_react.memo)(function(e2) {
  var r2 = e2.radius, t2 = zt(), n2 = Ur(), o2 = n2.animate, i2 = n2.config, d = useSpring({ radius: r2, config: i2, immediate: !o2 });
  return (0, import_jsx_runtime.jsx)(animated.circle, z({ fill: "none", r: to(d.radius, function(e3) {
    return Math.max(e3, 0);
  }) }, t2.grid.line));
});
var R = function(r2) {
  var t2 = r2.radius, n2 = r2.rotation, o2 = r2.angleStep, i2 = r2.dataLength, l = zt(), u = (0, import_react.useMemo)(function() {
    return lineRadial_default().angle(function(e2) {
      return n2 + e2 * o2;
    }).radius(t2).curve(linearClosed_default);
  }, [n2, o2, t2]), c = Array.from({ length: i2 }, function(e2, r3) {
    return r3;
  }), s = Fr(u(c));
  return (0, import_jsx_runtime.jsx)(animated.path, z({ fill: "none", d: s }, l.grid.line));
};
var q = function(e2) {
  var r2 = e2.shape, t2 = j(e2, H);
  return "circular" === r2 ? (0, import_jsx_runtime.jsx)(G, { radius: t2.radius }) : (0, import_jsx_runtime.jsx)(R, z({}, t2));
};
var J = function(r2) {
  var t2 = r2.indices, n2 = r2.levels, o2 = r2.shape, i2 = r2.radius, l = r2.rotation, d = r2.angleStep, c = r2.label, s = r2.labelOffset, f = zt(), m = (0, import_react.useMemo)(function() {
    return { radii: Array.from({ length: n2 }).map(function(e2, r3) {
      return i2 / n2 * (r3 + 1);
    }).reverse(), angles: Array.from({ length: t2.length }).map(function(e2, r3) {
      return l + r3 * d - Math.PI / 2;
    }) };
  }, [t2, n2, i2, l, d]), g2 = m.radii, v = m.angles;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [v.map(function(e2, r3) {
    var t3 = Jt(e2, i2);
    return (0, import_jsx_runtime.jsx)("line", z({ x1: 0, y1: 0, x2: t3.x, y2: t3.y }, f.grid.line), "axis." + r3);
  }), g2.map(function(e2, r3) {
    return (0, import_jsx_runtime.jsx)(q, { shape: o2, radius: e2, rotation: l, angleStep: d, dataLength: t2.length }, "level." + r3);
  }), (0, import_jsx_runtime.jsx)(E, { radius: i2, angles: v, indices: t2, labelOffset: s, label: c })] });
};
var N = function(t2) {
  var i2 = t2.datum, l = t2.keys, d = t2.index, c = t2.formatValue, s = t2.colorByKey, f = t2.radius, m = t2.startAngle, g2 = t2.endAngle, v = t2.arcGenerator, y = t2.tooltip, h = t2.onClick, p = (0, import_react.useState)(false), b = p[0], x = p[1], k2 = zt(), B = k(), L = B.showTooltipFromEvent, S = B.hideTooltip, C2 = (0, import_react.useCallback)(function(e2) {
    return null == h ? void 0 : h(i2, e2);
  }, [h, i2]), O2 = (0, import_react.useMemo)(function() {
    var e2 = l.map(function(e3) {
      return { color: s[e3], id: e3, value: i2[e3], formattedValue: c(i2[e3], e3) };
    });
    return e2.sort(function(e3, r2) {
      return e3.value - r2.value;
    }), e2.reverse(), e2;
  }, [i2, l, c, s]), I = (0, import_react.useCallback)(function(e2) {
    x(true), L((0, import_react.createElement)(y, { index: d, data: O2 }), e2);
  }, [L, y, d, O2]), M = (0, import_react.useCallback)(function() {
    x(false), S();
  }, [S, x]), W = (0, import_react.useMemo)(function() {
    var e2 = Jt(m + 0.5 * (g2 - m) - Math.PI / 2, f);
    return { path: v({ startAngle: m, endAngle: g2 }), tipX: e2.x, tipY: e2.y };
  }, [m, g2, f, v]), K = W.path, V = W.tipX, F = W.tipY;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [b && (0, import_jsx_runtime.jsx)("line", { x1: 0, y1: 0, x2: V, y2: F, style: k2.crosshair.line }), (0, import_jsx_runtime.jsx)("path", { d: K, fill: "#F00", fillOpacity: 0, onMouseEnter: I, onMouseMove: I, onMouseLeave: M, onClick: C2 })] });
};
var Q = function(e2) {
  var r2 = e2.data, t2 = e2.keys, n2 = e2.getIndex, o2 = e2.formatValue, i2 = e2.colorByKey, a = e2.radius, l = e2.rotation, d = e2.angleStep, u = e2.tooltip, c = e2.onClick, s = arc_default().outerRadius(a).innerRadius(0), f = l - 0.5 * d;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: r2.map(function(e3) {
    var r3 = n2(e3), l2 = f;
    return f += d, (0, import_jsx_runtime.jsx)(N, { datum: e3, keys: t2, index: r3, formatValue: o2, colorByKey: i2, startAngle: l2, endAngle: l2 + d, radius: a, arcGenerator: s, tooltip: u, onClick: c }, r3);
  }) });
};
var U = function(r2) {
  var t2 = r2.data, n2 = r2.keys, o2 = r2.getIndex, i2 = r2.colorByKey, l = r2.radiusScale, d = r2.rotation, c = r2.angleStep, m = r2.symbol, g2 = r2.size, v = void 0 === g2 ? 6 : g2, y = r2.color, h = void 0 === y ? { from: "color" } : y, p = r2.borderWidth, b = void 0 === p ? 0 : p, x = r2.borderColor, k2 = void 0 === x ? { from: "color" } : x, B = r2.enableLabel, L = void 0 !== B && B, S = r2.label, C2 = void 0 === S ? "value" : S, O2 = r2.formatValue, I = r2.labelYOffset, M = zt(), W = We(h, M), V = We(k2, M), w2 = Wn(C2), A = (0, import_react.useMemo)(function() {
    return t2.reduce(function(e2, r3, t3) {
      var a = o2(r3);
      return n2.forEach(function(n3) {
        var o3 = r3[n3], s = { index: a, key: n3, value: o3, formattedValue: O2(o3, n3), color: i2[n3] };
        e2.push({ key: n3 + "." + a, label: L ? w2(s) : void 0, style: z({ fill: W(s), stroke: V(s) }, Jt(d + c * t3 - Math.PI / 2, l(r3[n3]))), data: s });
      }), e2;
    }, []);
  }, [t2, n2, o2, i2, L, w2, O2, W, V, d, c, l]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: A.map(function(e2) {
    return (0, import_jsx_runtime.jsx)(vn, { x: e2.style.x, y: e2.style.y, symbol: m, size: v, color: e2.style.fill, borderWidth: b, borderColor: e2.style.stroke, label: e2.label, labelYOffset: I, datum: e2.data }, e2.key);
  }) });
};
var Z = { layers: ["grid", "layers", "slices", "dots", "legends"], maxValue: "auto", rotation: 0, curve: "linearClosed", borderWidth: 2, borderColor: { from: "color" }, gridLevels: 5, gridShape: "circular", gridLabelOffset: 16, gridLabel: function(e2) {
  var r2 = e2.id, t2 = e2.anchor, n2 = e2.animated, o2 = zt();
  return (0, import_jsx_runtime.jsx)(animated.g, { transform: n2.transform, children: (0, import_jsx_runtime.jsx)("text", { style: o2.axis.ticks.text, dominantBaseline: "central", textAnchor: t2, children: r2 }) });
}, enableDots: true, dotSize: 6, dotColor: { from: "color" }, dotBorderWidth: 0, dotBorderColor: { from: "color" }, enableDotLabel: false, dotLabel: "formattedValue", dotLabelYOffset: -12, colors: { scheme: "nivo" }, fillOpacity: 0.25, blendMode: "normal", isInteractive: true, sliceTooltip: function(r2) {
  var t2 = r2.index, n2 = r2.data, o2 = (0, import_react.useMemo)(function() {
    return n2.map(function(e2) {
      return [(0, import_jsx_runtime.jsx)(g, { color: e2.color }, e2.id), e2.id, e2.formattedValue];
    });
  }, [n2]);
  return (0, import_jsx_runtime.jsx)(C, { title: (0, import_jsx_runtime.jsx)("strong", { children: t2 }), rows: o2 });
}, legends: [], role: "img", animate: true, motionConfig: "gentle", defs: [], fill: [] };
var $ = ["data"];
var _ = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var ee = function(t2) {
  var n2 = t2.data, o2 = t2.keys, a = t2.indexBy, l = t2.layers, d = void 0 === l ? Z.layers : l, u = t2.rotation, c = void 0 === u ? Z.rotation : u, f = t2.maxValue, h = void 0 === f ? Z.maxValue : f, x = t2.valueFormat, B = t2.curve, L = void 0 === B ? Z.curve : B, S = t2.margin, C2 = t2.width, O2 = t2.height, I = t2.borderWidth, M = void 0 === I ? Z.borderWidth : I, W = t2.borderColor, K = void 0 === W ? Z.borderColor : W, Y2 = t2.gridLevels, w2 = void 0 === Y2 ? Z.gridLevels : Y2, A = t2.gridShape, F = void 0 === A ? Z.gridShape : A, P = t2.gridLabel, E2 = void 0 === P ? Z.gridLabel : P, H2 = t2.gridLabelOffset, G2 = void 0 === H2 ? Z.gridLabelOffset : H2, R2 = t2.enableDots, q2 = void 0 === R2 ? Z.enableDots : R2, N2 = t2.dotSymbol, _2 = t2.dotSize, ee2 = void 0 === _2 ? Z.dotSize : _2, re2 = t2.dotColor, te2 = void 0 === re2 ? Z.dotColor : re2, ne = t2.dotBorderWidth, oe = void 0 === ne ? Z.dotBorderWidth : ne, ie = t2.dotBorderColor, ae = void 0 === ie ? Z.dotBorderColor : ie, le = t2.enableDotLabel, de = void 0 === le ? Z.enableDotLabel : le, ue = t2.dotLabel, ce = void 0 === ue ? Z.dotLabel : ue, se = t2.dotLabelYOffset, fe = void 0 === se ? Z.dotLabelYOffset : se, me = t2.colors, ge = void 0 === me ? Z.colors : me, ve = t2.fillOpacity, ye = void 0 === ve ? Z.fillOpacity : ve, he = t2.blendMode, pe = void 0 === he ? Z.blendMode : he, be = t2.isInteractive, xe = void 0 === be ? Z.isInteractive : be, ke = t2.sliceTooltip, Be = void 0 === ke ? Z.sliceTooltip : ke, Le = t2.legends, Se = void 0 === Le ? Z.legends : Le, Ce = t2.role, Oe = t2.ariaLabel, Ie = t2.ariaLabelledBy, Me = t2.ariaDescribedBy, We2 = t2.defs, Ke = void 0 === We2 ? Z.defs : We2, Ve = t2.fill, De = void 0 === Ve ? Z.fill : Ve, Ye = t2.onClick, we = wt(C2, O2, S), Ae = we.margin, Fe = we.innerWidth, Pe = we.innerHeight, Xe2 = we.outerWidth, ze = we.outerHeight, je = function(r2) {
    var t3 = r2.data, n3 = r2.keys, o3 = r2.indexBy, i2 = r2.rotationDegrees, a2 = r2.maxValue, l2 = r2.valueFormat, d2 = r2.curve, u2 = r2.width, c2 = r2.height, f2 = r2.colors, h2 = void 0 === f2 ? Z.colors : f2, p = r2.legends, b = r2.defs, x2 = r2.fill, k2 = Wn(o3), B2 = (0, import_react.useMemo)(function() {
      return t3.map(k2);
    }, [t3, k2]), L2 = Ot(l2), S2 = Ht(i2), C3 = pr(h2, "key"), O3 = (0, import_react.useMemo)(function() {
      return n3.reduce(function(e2, r3, t4) {
        return e2[r3] = C3({ key: r3, index: t4 }), e2;
      }, {});
    }, [n3, C3]), I2 = (0, import_react.useMemo)(function() {
      var e2 = n3.map(function(e3) {
        return { key: e3, color: O3[e3], data: t3, fill: null };
      }), r3 = In(b, e2, x2), o4 = e2.reduce(function(e3, r4) {
        var t4 = r4.key, n4 = r4.fill;
        return e3[t4] = n4, e3;
      }, {});
      return { boundDefs: r3, fillByKey: o4 };
    }, [n3, t3, b, x2, O3]), M2 = I2.boundDefs, W2 = I2.fillByKey, K2 = (0, import_react.useMemo)(function() {
      var e2 = t3.reduce(function(e3, r4) {
        return [].concat(e3, n3.map(function(e4) {
          return r4[e4];
        }));
      }, []), r3 = "auto" !== a2 ? a2 : Math.max.apply(Math, e2), o4 = Math.min(u2, c2) / 2;
      return { radius: o4, radiusScale: linear().range([0, o4]).domain([0, r3]), centerX: u2 / 2, centerY: c2 / 2, angleStep: 2 * Math.PI / t3.length };
    }, [n3, t3, a2, u2, c2]), D2 = K2.radius, Y3 = K2.radiusScale, w3 = K2.centerX, A2 = K2.centerY, F2 = K2.angleStep, P2 = bt(d2), T2 = (0, import_react.useMemo)(function() {
      return { data: t3, keys: n3, indices: B2, colorByKey: O3, centerX: w3, centerY: A2, radiusScale: Y3, angleStep: F2 };
    }, [t3, n3, B2, O3, w3, A2, Y3, F2]), E3 = (0, import_react.useMemo)(function() {
      return n3.map(function(e2) {
        return { id: e2, label: e2, color: O3[e2] };
      });
    }, [n3, O3]), H3 = (0, import_react.useMemo)(function() {
      return p.map(function(e2) {
        var r3 = e2.data, t4 = j(e2, $), n4 = null == r3 ? void 0 : r3.map(function(e3) {
          return z({}, E3.find(function(r4) {
            return r4.id === e3.id;
          }) || {}, e3);
        });
        return z({}, t4, { data: n4 || E3 });
      });
    }, [p, E3]);
    return { getIndex: k2, indices: B2, formatValue: L2, colorByKey: O3, fillByKey: W2, boundDefs: M2, rotation: S2, radius: D2, radiusScale: Y3, centerX: w3, centerY: A2, angleStep: F2, curveFactory: P2, legendData: E3, boundLegends: H3, customLayerProps: T2 };
  }({ data: n2, keys: o2, indexBy: a, rotationDegrees: c, maxValue: h, valueFormat: x, curve: L, width: Fe, height: Pe, colors: ge, legends: Se, defs: Ke, fill: De }), Te = je.getIndex, Ee = je.indices, He = je.formatValue, Ge = je.colorByKey, Re = je.fillByKey, qe = je.boundDefs, Je = je.rotation, Ne = je.radius, Qe = je.radiusScale, Ue = je.centerX, Ze = je.centerY, $e = je.angleStep, _e = je.curveFactory, er = je.boundLegends, rr = je.customLayerProps, tr = { grid: null, layers: null, slices: null, dots: null, legends: null };
  return d.includes("grid") && (tr.grid = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Ue + ", " + Ze + ")", children: (0, import_jsx_runtime.jsx)(J, { levels: w2, shape: F, radius: Ne, rotation: Je, angleStep: $e, indices: Ee, label: E2, labelOffset: G2 }) }, "grid")), d.includes("layers") && (tr.layers = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Ue + ", " + Ze + ")", children: o2.map(function(e2) {
    return (0, import_jsx_runtime.jsx)(T, { data: n2, item: e2, colorByKey: Ge, fillByKey: Re, radiusScale: Qe, rotation: Je, angleStep: $e, curveFactory: _e, borderWidth: M, borderColor: K, fillOpacity: ye, blendMode: pe }, e2);
  }) }, "layers")), d.includes("slices") && xe && (tr.slices = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Ue + ", " + Ze + ")", children: (0, import_jsx_runtime.jsx)(Q, { data: n2, keys: o2, getIndex: Te, formatValue: He, colorByKey: Ge, radius: Ne, rotation: Je, angleStep: $e, tooltip: Be, onClick: Ye }) }, "slices")), d.includes("dots") && q2 && (tr.dots = (0, import_jsx_runtime.jsx)("g", { transform: "translate(" + Ue + ", " + Ze + ")", children: (0, import_jsx_runtime.jsx)(U, { data: n2, keys: o2, getIndex: Te, radiusScale: Qe, rotation: Je, angleStep: $e, symbol: N2, size: ee2, colorByKey: Ge, color: te2, borderWidth: oe, borderColor: ae, enableLabel: de, label: ce, formatValue: He, labelYOffset: fe }) }, "dots")), d.includes("legends") && (tr.legends = (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: er.map(function(e2, r2) {
    return (0, import_jsx_runtime.jsx)(O, z({}, e2, { containerWidth: C2, containerHeight: O2 }), r2);
  }) }, "legends")), (0, import_jsx_runtime.jsx)(gn, { defs: qe, width: Xe2, height: ze, margin: Ae, role: Ce, ariaLabel: Oe, ariaLabelledBy: Ie, ariaDescribedBy: Me, children: d.map(function(e2, t3) {
    var n3;
    return "function" == typeof e2 ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(e2, rr) }, t3) : null != (n3 = null == tr ? void 0 : tr[e2]) ? n3 : null;
  }) });
};
var re = function(e2) {
  var r2 = e2.isInteractive, t2 = void 0 === r2 ? Z.isInteractive : r2, n2 = e2.animate, o2 = void 0 === n2 ? Z.animate : n2, i2 = e2.motionConfig, a = void 0 === i2 ? Z.motionConfig : i2, l = e2.theme, d = e2.renderWrapper, u = j(e2, _);
  return (0, import_jsx_runtime.jsx)(St, { animate: o2, isInteractive: t2, motionConfig: a, renderWrapper: d, theme: l, children: (0, import_jsx_runtime.jsx)(ee, z({ isInteractive: t2 }, u)) });
};
var te = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(r2) {
    var t2 = r2.width, n2 = r2.height;
    return (0, import_jsx_runtime.jsx)(re, z({ width: t2, height: n2 }, e2));
  } });
};
export {
  re as Radar,
  U as RadarDots,
  te as ResponsiveRadar,
  Z as svgDefaultProps
};
//# sourceMappingURL=@nivo_radar.js.map
