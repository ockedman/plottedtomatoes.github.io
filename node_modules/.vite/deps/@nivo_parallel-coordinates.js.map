{
  "version": 3,
  "sources": ["../../@nivo/parallel-coordinates/src/ParallelCoordinatesLineTooltip.tsx", "../../@nivo/parallel-coordinates/src/defaults.ts", "../../@nivo/parallel-coordinates/src/hooks.ts", "../../@nivo/parallel-coordinates/src/svg/ParallelCoordinatesLine.tsx", "../../@nivo/parallel-coordinates/src/svg/ParallelCoordinates.tsx", "../../@nivo/parallel-coordinates/src/svg/ResponsiveParallelCoordinates.tsx", "../../@nivo/parallel-coordinates/src/canvas/ParallelCoordinatesCanvas.tsx", "../../@nivo/parallel-coordinates/src/canvas/ResponsiveParallelCoordinatesCanvas.tsx"],
  "sourcesContent": ["import { TableTooltip } from '@nivo/tooltip'\nimport { BaseDatum, TooltipProps, DatumGroupKeys } from './types'\n\nexport const ParallelCoordinatesLineTooltip = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    datum,\n    variables,\n}: TooltipProps<Datum, GroupBy>) => {\n    return (\n        <TableTooltip\n            rows={variables.map(variable => [\n                variable.label || variable.id,\n                <strong>{datum.data[variable.value] as number}</strong>, // eslint-disable-line react/jsx-key\n            ])}\n        />\n    )\n}\n", "import { CommonProps, BaseDatum, LayerId } from './types'\nimport { ParallelCoordinatesLineTooltip } from './ParallelCoordinatesLineTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonProps<BaseDatum>,\n    | 'groupBy'\n    | 'groups'\n    | 'margin'\n    | 'theme'\n    | 'forwardLegendData'\n    | 'renderWrapper'\n    | 'ariaLabel'\n    | 'ariaLabelledBy'\n    | 'ariaDescribedBy'\n> = {\n    layout: 'horizontal',\n    curve: 'linear',\n\n    role: 'img',\n\n    colors: { scheme: 'category10' },\n    lineWidth: 2,\n    lineOpacity: 0.5,\n\n    axesTicksPosition: 'after',\n\n    isInteractive: true,\n    tooltip: ParallelCoordinatesLineTooltip,\n\n    legends: [],\n\n    animate: true,\n    motionConfig: 'gentle',\n}\n\nexport const svgDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n}\n\nexport const canvasDefaultProps = {\n    ...commonDefaultProps,\n    layers: ['lines', 'axes', 'legends'] as LayerId[],\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1,\n}\n", "import { useMemo, useRef, useEffect } from 'react'\nimport { line } from 'd3-shape'\nimport { scaleLinear, scalePoint } from 'd3-scale'\nimport { curveFromProp } from '@nivo/core'\nimport { OrdinalColorScaleConfig, useOrdinalColorScale } from '@nivo/colors'\nimport { castPointScale, castLinearScale, ScalePoint } from '@nivo/scales'\nimport {\n    Variable,\n    VariableWithScale,\n    CommonProps,\n    ComputedDatum,\n    BaseDatum,\n    BaseGroup,\n    Group,\n    CustomLayerProps,\n    GroupLegend,\n    DatumLegend,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from './types'\nimport { commonDefaultProps } from './defaults'\n\n/**\n * Compute groups.\n *\n * Please note that we assume that `groupBy` is defined, and correct, at this stage.\n *\n * If `predefinedGroups` is provided, we'll use it as a base, otherwise\n * we're going to scan each datum and extract their group, and then\n * make those unique to define the available groups.\n */\nconst computeGroups = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    predefinedGroups,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy: DatumGroupKeys<Datum>\n    predefinedGroups?: readonly BaseGroup[]\n    getColor: (group: BaseGroup) => string\n}): Group[] => {\n    let groups: Group[]\n\n    if (predefinedGroups !== undefined) {\n        groups = predefinedGroups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: getColor(group),\n        }))\n    } else {\n        const groupsSet = new Set<string>()\n        for (const datum of data) {\n            groupsSet.add(datum[groupBy] as string)\n        }\n\n        groups = Array.from(groupsSet, groupId => {\n            const group: BaseGroup = {\n                id: groupId,\n                label: groupId,\n            }\n\n            return {\n                ...group,\n                color: getColor(group),\n            }\n        })\n    }\n\n    return groups\n}\n\n/**\n * Compute the scale for each variable.\n *\n * We only support linear scales.\n *\n * Each scale domain will be computed automatically if `min`/`max` = `'auto'`,\n * otherwise, we'll use the provided values.\n */\nconst computeVariablesScales = <Datum extends BaseDatum>({\n    width,\n    height,\n    data,\n    variables,\n    layout,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    layout: CommonProps<Datum>['layout']\n}): readonly VariableWithScale<Datum>[] => {\n    // Depending on the layout, the range might need to be switched.\n    const range = layout === 'horizontal' ? [height, 0] : [0, width]\n\n    return variables.map(variable => {\n        const allValues: number[] = data.map(datum => datum[variable.value] as number)\n\n        const min =\n            variable.min !== undefined && variable.min !== 'auto'\n                ? variable.min\n                : Math.min(...allValues!)\n        const max =\n            variable.max !== undefined && variable.max !== 'auto'\n                ? variable.max\n                : Math.max(...allValues!)\n\n        const scale = castLinearScale(scaleLinear().rangeRound(range).domain([min, max]))\n\n        return { ...variable, scale }\n    })\n}\n\nconst computeDataVariables = <Datum extends BaseDatum>({\n    data,\n    groupBy,\n    groups,\n    variablesScale,\n    variablesWithScale,\n    layout,\n    getColor,\n}: {\n    data: readonly Datum[]\n    groupBy?: DatumGroupKeys<Datum>\n    groups: Group[] | undefined\n    variablesScale: ScalePoint<string>\n    variablesWithScale: readonly VariableWithScale<Datum>[]\n    layout: CommonProps<Datum>['layout']\n    getColor: (datum: Datum) => string\n}): ComputedDatum<Datum>[] | ComputedGroupDatum<Datum>[] => {\n    return data.map((datum, index) => {\n        const points: [number, number][] = variablesWithScale.map(variable => [\n            layout === 'horizontal'\n                ? variablesScale(variable.id)!\n                : variable.scale(datum[variable.value] as number),\n            layout === 'horizontal'\n                ? variable.scale(datum[variable.value] as number)\n                : variablesScale(variable.id)!,\n        ])\n\n        let group: Group | undefined = undefined\n        if (groupBy !== undefined) {\n            const datumGroup = datum[groupBy]\n            group = groups?.find(candidateGroup => candidateGroup.id === datumGroup)\n        }\n\n        const computedDatum: ComputedDatum<Datum> = {\n            id: datum.id,\n            index,\n            points,\n            data: datum,\n            color: group ? group.color : getColor(datum),\n        }\n\n        if (!group) return computedDatum\n\n        return {\n            ...computedDatum,\n            group,\n        } as ComputedGroupDatum<Datum>\n    })\n}\n\nexport const useParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    width,\n    height,\n    data,\n    variables,\n    groupBy,\n    groups: predefinedGroups,\n    layout = commonDefaultProps.layout,\n    curve = commonDefaultProps.curve,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<\n        IfGrouped<Datum, GroupBy, BaseGroup, Datum>\n    >,\n    forwardLegendData,\n}: {\n    width: number\n    height: number\n    data: readonly Datum[]\n    variables: readonly Variable<Datum>[]\n    groupBy?: CommonProps<Datum, GroupBy>['groupBy']\n    groups?: CommonProps<Datum, GroupBy>['groups']\n    layout: CommonProps<Datum, GroupBy>['layout']\n    curve: CommonProps<Datum, GroupBy>['curve']\n    colors: CommonProps<Datum, GroupBy>['colors']\n    forwardLegendData?: CommonProps<Datum, GroupBy>['forwardLegendData']\n}) => {\n    // If no groups, we'll use the data to define the color, otherwise the groups,\n    // meaning that `id` refers to either `Datum.id` or `Group.id`.\n    const getColor = useOrdinalColorScale(colors, 'id')\n\n    const groups = useMemo(() => {\n        if (groupBy === undefined) return undefined\n\n        return computeGroups<Datum>({\n            data,\n            groupBy,\n            predefinedGroups,\n            getColor: getColor as (group: BaseGroup) => string,\n        })\n    }, [data, groupBy, predefinedGroups, getColor])\n\n    const variablesScale = useMemo(() => {\n        const variableIds = variables.map(({ id }) => id)\n        return castPointScale(\n            scalePoint()\n                .range(layout === 'horizontal' ? [0, width] : [height, 0])\n                .domain(variableIds)\n        )\n    }, [variables, layout, width, height])\n\n    const variablesWithScale = useMemo(\n        () =>\n            computeVariablesScales<Datum>({\n                width,\n                height,\n                data,\n                variables,\n                layout,\n            }),\n        [width, height, data, variables, layout]\n    )\n\n    const computedData = useMemo(\n        () =>\n            computeDataVariables<Datum>({\n                data,\n                groupBy,\n                groups,\n                variablesScale,\n                variablesWithScale,\n                layout,\n                getColor,\n            }),\n        [data, groupBy, groups, variablesScale, variablesWithScale, layout, getColor]\n    )\n\n    const legendData = useMemo(() => {\n        if (!groups) {\n            return computedData.map(datum => ({\n                id: datum.id,\n                label: datum.id,\n                color: datum.color,\n                data: datum,\n            })) as DatumLegend<Datum>[]\n        }\n\n        return groups.map(group => ({\n            id: group.id,\n            label: group.label || group.id,\n            color: group.color,\n            data: group,\n        })) as GroupLegend[]\n    }, [groups, computedData])\n\n    // Forward the legends data if `forwardLegendData` is defined.\n    const forwardLegendDataRef = useRef(forwardLegendData)\n    useEffect(() => {\n        if (typeof forwardLegendDataRef.current !== 'function') return\n        forwardLegendDataRef.current(\n            legendData as IfGrouped<Datum, GroupBy, GroupLegend[], DatumLegend<Datum>[]>\n        )\n    }, [forwardLegendDataRef, legendData])\n\n    const lineGenerator = useMemo(\n        () => line<[number, number]>().curve(curveFromProp(curve)),\n        [curve]\n    )\n\n    const customLayerContext: CustomLayerProps<Datum> = useMemo(\n        () => ({\n            computedData,\n            variables,\n            lineGenerator,\n        }),\n        [computedData, variables, lineGenerator]\n    )\n\n    return {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    }\n}\n", "import { useCallback, MouseEvent, createElement } from 'react'\nimport { Line } from 'd3-shape'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport {\n    BaseDatum,\n    ComputedDatum,\n    Variable,\n    TooltipComponent,\n    DatumGroupKeys,\n    IfGrouped,\n    ComputedGroupDatum,\n} from '../types'\n\nexport const ParallelCoordinatesLine = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    datum,\n    variables,\n    lineGenerator,\n    lineWidth,\n    opacity,\n    tooltip,\n    testIdPrefix,\n}: {\n    datum: IfGrouped<Datum, GroupBy, ComputedGroupDatum<Datum>, ComputedDatum<Datum>>\n    variables: readonly Variable<Datum>[]\n    lineGenerator: Line<[number, number]>\n    lineWidth: number\n    opacity: number\n    tooltip: TooltipComponent<Datum, GroupBy>\n    testIdPrefix?: string\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { datum, variables }), event)\n        },\n        [showTooltipFromEvent, datum, variables]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(lineGenerator(datum.points)!)\n    const animatedProps = useSpring({\n        color: datum.color,\n        opacity,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            stroke={animatedProps.color}\n            strokeWidth={lineWidth}\n            strokeLinecap=\"round\"\n            opacity={animatedProps.opacity}\n            fill=\"none\"\n            onMouseEnter={handleMouseHover}\n            onMouseMove={handleMouseHover}\n            onMouseLeave={hideTooltip}\n            data-test-id={testIdPrefix ? `${testIdPrefix}.line_${datum.id}` : undefined}\n        />\n    )\n}\n", "import { createElement, Fragment, ReactNode } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { Axis } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { svgDefaultProps } from '../defaults'\nimport { useParallelCoordinates } from '../hooks'\nimport {\n    ParallelCoordinatesProps,\n    BaseDatum,\n    LayerId,\n    DatumGroupKeys,\n    TooltipComponent,\n    IfGrouped,\n    ComputedGroupDatum,\n    ComputedDatum,\n} from '../types'\nimport { ParallelCoordinatesLine } from './ParallelCoordinatesLine'\n\ntype InnerParallelCoordinatesProps<\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n> = Omit<\n    ParallelCoordinatesProps<Datum, GroupBy>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined\n>({\n    data,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    layout = svgDefaultProps.layout,\n    curve = svgDefaultProps.curve,\n    axesTicksPosition,\n    lineWidth = svgDefaultProps.lineWidth,\n    lineOpacity = svgDefaultProps.lineOpacity,\n    colors = svgDefaultProps.colors,\n    layers = svgDefaultProps.layers,\n    tooltip = svgDefaultProps.tooltip as unknown as TooltipComponent<Datum, GroupBy>,\n    legends = svgDefaultProps.legends,\n    forwardLegendData,\n    role = svgDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    testIdPrefix,\n}: InnerParallelCoordinatesProps<Datum, GroupBy>) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<Datum, GroupBy>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const layerById: Record<LayerId, ReactNode> = {\n        axes: null,\n        lines: null,\n        legends: null,\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <g key=\"axes\">\n                {variablesWithScale.map(variable => (\n                    <Axis\n                        key={variable.id}\n                        axis={layout === 'horizontal' ? 'y' : 'x'}\n                        length={layout === 'horizontal' ? innerHeight : innerWidth}\n                        x={layout === 'horizontal' ? variablesScale(variable.id) : 0}\n                        y={layout === 'horizontal' ? 0 : variablesScale(variable.id)}\n                        scale={variable.scale}\n                        ticksPosition={variable.ticksPosition || axesTicksPosition}\n                        tickValues={variable.tickValues}\n                        tickSize={variable.tickSize}\n                        tickPadding={variable.tickPadding}\n                        tickRotation={variable.tickRotation}\n                        format={variable.tickFormat}\n                        legend={variable.label || variable.id}\n                        legendPosition={variable.legendPosition}\n                        legendOffset={variable.legendOffset}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <g key=\"lines\">\n                {computedData.map(datum => (\n                    <ParallelCoordinatesLine<Datum, GroupBy>\n                        key={`${'group' in datum ? datum.group.id : ''}${datum.id}`}\n                        datum={\n                            datum as IfGrouped<\n                                Datum,\n                                GroupBy,\n                                ComputedGroupDatum<Datum>,\n                                ComputedDatum<Datum>\n                            >\n                        }\n                        variables={variables}\n                        lineGenerator={lineGenerator}\n                        lineWidth={lineWidth}\n                        opacity={lineOpacity}\n                        tooltip={tooltip}\n                        testIdPrefix={testIdPrefix}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <g key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legendData}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, customLayerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const ParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesProps<Datum, GroupBy>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerParallelCoordinates<Datum, GroupBy> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n", "import { ResponsiveWrapper } from '@nivo/core'\nimport { ParallelCoordinatesProps, BaseDatum, DatumGroupKeys } from '../types'\nimport { ParallelCoordinates } from './ParallelCoordinates'\n\nexport const ResponsiveParallelCoordinates = <\n    Datum extends BaseDatum,\n    GroupBy extends DatumGroupKeys<Datum> | undefined = undefined\n>(\n    props: Omit<ParallelCoordinatesProps<Datum, GroupBy>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinates<Datum, GroupBy> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n", "import { useEffect, useRef } from 'react'\nimport { Container, useDimensions, useTheme } from '@nivo/core'\nimport { renderAxisToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useParallelCoordinates } from '../hooks'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { canvasDefaultProps } from '../defaults'\n\ntype InnerParallelCoordinatesCanvasProps<D extends BaseDatum> = Omit<\n    ParallelCoordinatesCanvasProps<D>,\n    'renderWrapper' | 'theme'\n>\n\nexport const InnerParallelCoordinatesCanvas = <D extends BaseDatum>({\n    data,\n    layout = canvasDefaultProps.layout,\n    variables,\n    groupBy,\n    groups,\n    width,\n    height,\n    margin: partialMargin,\n    curve = canvasDefaultProps.curve,\n    colors = canvasDefaultProps.colors,\n    lineOpacity = canvasDefaultProps.lineOpacity,\n    lineWidth = canvasDefaultProps.lineWidth,\n    axesTicksPosition = canvasDefaultProps.axesTicksPosition,\n    legends = canvasDefaultProps.legends,\n    forwardLegendData,\n    layers = canvasDefaultProps.layers,\n    role = canvasDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n}: InnerParallelCoordinatesCanvasProps<D>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        variablesScale,\n        variablesWithScale,\n        computedData,\n        lineGenerator,\n        legendData,\n        customLayerContext,\n    } = useParallelCoordinates<D>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        variables,\n        groupBy,\n        groups,\n        layout,\n        colors,\n        curve,\n        forwardLegendData,\n    })\n\n    const theme = useTheme()\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        const ctx = canvasEl.current.getContext('2d')\n        if (ctx === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (layer === 'axes') {\n                variablesWithScale.forEach(variable => {\n                    renderAxisToCanvas(ctx, {\n                        axis: layout === 'horizontal' ? 'y' : 'x',\n                        scale: variable.scale,\n                        x: layout === 'horizontal' ? variablesScale(variable.id) : 0,\n                        y: layout === 'horizontal' ? 0 : variablesScale(variable.id),\n                        length: layout === 'horizontal' ? innerHeight : innerWidth,\n                        ticksPosition: axesTicksPosition,\n                        theme,\n                    })\n                })\n            } else if (layer === 'lines') {\n                lineGenerator.context(ctx)\n\n                computedData.forEach(datum => {\n                    ctx.save()\n                    ctx.globalAlpha = lineOpacity\n\n                    ctx.beginPath()\n                    lineGenerator(datum.points)\n                    ctx.strokeStyle = datum.color\n                    ctx.lineWidth = lineWidth\n                    ctx.stroke()\n\n                    ctx.restore()\n                })\n            } else if (layer === 'legends') {\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            } else if (typeof layer === 'function') {\n                layer(ctx, customLayerContext)\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        innerWidth,\n        innerHeight,\n        margin,\n        layers,\n        customLayerContext,\n        lineGenerator,\n        lineOpacity,\n        lineWidth,\n        computedData,\n        variablesScale,\n        variablesWithScale,\n        layout,\n        axesTicksPosition,\n        legends,\n        legendData,\n        theme,\n        pixelRatio,\n    ])\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n            }}\n            role={role}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledBy}\n            aria-describedby={ariaDescribedBy}\n        />\n    )\n}\n\nexport const ParallelCoordinatesCanvas = <D extends BaseDatum>({\n    theme,\n    isInteractive = canvasDefaultProps.isInteractive,\n    animate = canvasDefaultProps.animate,\n    motionConfig = canvasDefaultProps.motionConfig,\n    renderWrapper,\n    ...otherProps\n}: ParallelCoordinatesCanvasProps<D>) => (\n    <Container {...{ isInteractive, animate, motionConfig, theme, renderWrapper }}>\n        <InnerParallelCoordinatesCanvas<D> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n", "import { ResponsiveWrapper } from '@nivo/core'\nimport { BaseDatum, ParallelCoordinatesCanvasProps } from '../types'\nimport { ParallelCoordinatesCanvas } from './ParallelCoordinatesCanvas'\n\nexport const ResponsiveParallelCoordinatesCanvas = <D extends BaseDatum>(\n    props: Omit<ParallelCoordinatesCanvasProps<D>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <ParallelCoordinatesCanvas<D> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n"],
  "mappings": "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",
  "names": ["commonDefaultProps", "layout", "curve", "role", "colors", "scheme", "lineWidth", "lineOpacity", "axesTicksPosition", "isInteractive", "tooltip", "_ref", "datum", "variables", "_jsx", "TableTooltip", "rows", "map", "variable", "label", "id", "children", "data", "value", "legends", "animate", "motionConfig", "svgDefaultProps", "_extends", "layers", "canvasDefaultProps", "pixelRatio", "window", "_window$devicePixelRa", "devicePixelRatio", "useParallelCoordinates", "_ref4", "width", "height", "groupBy", "predefinedGroups", "groups", "_ref4$layout", "_ref4$curve", "_ref4$colors", "forwardLegendData", "getColor", "useOrdinalColorScale", "useMemo", "group", "color", "_step", "groupsSet", "Set", "_iterator", "_createForOfIteratorHelperLoose", "done", "add", "Array", "from", "groupId", "variablesScale", "variableIds", "_ref5", "castPointScale", "scalePoint", "range", "domain", "variablesWithScale", "_ref2", "allValues", "min", "Math", "apply", "max", "scale", "castLinearScale", "scaleLinear", "rangeRound", "computedData", "_ref3", "index", "points", "datumGroup", "find", "candidateGroup", "computedDatum", "legendData", "forwardLegendDataRef", "useRef", "useEffect", "current", "lineGenerator", "line", "curveFromProp", "customLayerContext", "ParallelCoordinatesLine", "opacity", "testIdPrefix", "_useTooltip", "useTooltip", "showTooltipFromEvent", "hideTooltip", "handleMouseHover", "useCallback", "event", "createElement", "_useMotionConfig", "useMotionConfig", "springConfig", "config", "animatedPath", "useAnimatedPath", "animatedProps", "useSpring", "immediate", "animated", "path", "d", "stroke", "strokeWidth", "strokeLinecap", "fill", "onMouseEnter", "onMouseMove", "onMouseLeave", "undefined", "InnerParallelCoordinates", "partialMargin", "margin", "_ref$layout", "_ref$curve", "_ref$lineWidth", "_ref$lineOpacity", "_ref$colors", "_ref$layers", "_ref$tooltip", "_ref$legends", "_ref$role", "ariaLabel", "ariaLabelledBy", "ariaDescribedBy", "_useDimensions", "useDimensions", "outerWidth", "outerHeight", "innerWidth", "innerHeight", "_useParallelCoordinat", "layerById", "axes", "lines", "includes", "Axis", "axis", "length", "x", "y", "ticksPosition", "tickValues", "tickSize", "tickPadding", "tickRotation", "format", "tickFormat", "legend", "legendPosition", "legendOffset", "i", "BoxLegendSvg", "containerWidth", "containerHeight", "SvgWrapper", "layer", "_layerById$layer", "Fragment", "ParallelCoordinates", "_ref2$isInteractive", "_ref2$animate", "_ref2$motionConfig", "theme", "renderWrapper", "otherProps", "_objectWithoutPropertiesLoose", "_excluded", "Container", "ResponsiveParallelCoordinates", "props", "ResponsiveWrapper", "InnerParallelCoordinatesCanvas", "_ref$axesTicksPositio", "_ref$pixelRatio", "canvasEl", "useTheme", "ctx", "getContext", "fillStyle", "background", "fillRect", "translate", "left", "top", "forEach", "renderAxisToCanvas", "context", "save", "globalAlpha", "beginPath", "strokeStyle", "restore", "renderLegendToCanvas", "ref", "style", "ParallelCoordinatesCanvas", "ResponsiveParallelCoordinatesCanvas"]
}
