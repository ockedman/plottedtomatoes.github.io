{
  "version": 3,
  "sources": ["../../@nivo/legends/src/svg/symbols/SymbolCircle.tsx", "../../@nivo/legends/src/svg/symbols/SymbolDiamond.tsx", "../../@nivo/legends/src/svg/symbols/SymbolSquare.tsx", "../../@nivo/legends/src/svg/symbols/SymbolTriangle.tsx", "../../@nivo/legends/src/defaults.ts", "../../@nivo/legends/src/compute.ts", "../../@nivo/legends/src/svg/ContinuousColorsLegendSvg.tsx", "../../@nivo/legends/src/svg/AnchoredContinuousColorsLegendSvg.tsx", "../../@nivo/legends/src/svg/LegendSvgItem.tsx", "../../@nivo/legends/src/svg/LegendSvg.tsx", "../../@nivo/legends/src/svg/BoxLegendSvg.tsx", "../../@nivo/legends/src/canvas.ts", "../../@nivo/legends/src/hooks.ts"],
  "sourcesContent": ["import { SymbolProps } from './types'\n\nexport const SymbolCircle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <circle\n            r={size / 2}\n            cx={x + size / 2}\n            cy={y + size / 2}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n", "import { SymbolProps } from './types'\n\nexport const SymbolDiamond = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                    M${size / 2} 0\n                    L${size * 0.8} ${size / 2}\n                    L${size / 2} ${size}\n                    L${size * 0.2} ${size / 2}\n                    L${size / 2} 0\n                `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n", "import { SymbolProps } from './types'\n\nexport const SymbolSquare = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <rect\n            x={x}\n            y={y}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            width={size}\n            height={size}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n", "import { SymbolProps } from './types'\n\nexport const SymbolTriangle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                M${size / 2} 0\n                L${size} ${size}\n                L0 ${size}\n                L${size / 2} 0\n            `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n", "import { ContinuousColorsLegendProps } from './types'\n\nexport const continuousColorsLegendDefaults: {\n    length: NonNullable<ContinuousColorsLegendProps['length']>\n    thickness: NonNullable<ContinuousColorsLegendProps['thickness']>\n    direction: NonNullable<ContinuousColorsLegendProps['direction']>\n    tickPosition: NonNullable<ContinuousColorsLegendProps['tickPosition']>\n    tickSize: NonNullable<ContinuousColorsLegendProps['tickSize']>\n    tickSpacing: NonNullable<ContinuousColorsLegendProps['tickSpacing']>\n    tickOverlap: NonNullable<ContinuousColorsLegendProps['tickOverlap']>\n    tickFormat: NonNullable<ContinuousColorsLegendProps['tickFormat']>\n    titleAlign: NonNullable<ContinuousColorsLegendProps['titleAlign']>\n    titleOffset: NonNullable<ContinuousColorsLegendProps['titleOffset']>\n} = {\n    length: 200,\n    thickness: 16,\n    direction: 'row',\n    tickPosition: 'after',\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: false,\n    tickFormat: (value: number) => `${value}`,\n    titleAlign: 'start',\n    titleOffset: 4,\n}\n", "import { scaleLinear } from 'd3-scale'\nimport { getValueFormatter } from '@nivo/core'\nimport { computeContinuousColorScaleColorStops } from '@nivo/colors'\nimport {\n    BoxLegendSvgProps,\n    ContinuousColorsLegendProps,\n    LegendAnchor,\n    LegendItemDirection,\n} from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst isObject = <T>(item: unknown): item is T =>\n    typeof item === 'object' && !Array.isArray(item) && item !== null\n\nconst zeroPadding = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n}\n\nexport const computeDimensions = ({\n    direction,\n    itemsSpacing,\n    padding: _padding,\n    itemCount,\n    itemWidth,\n    itemHeight,\n}: Pick<BoxLegendSvgProps, 'direction' | 'padding'> &\n    Record<'itemsSpacing' | 'itemCount' | 'itemWidth' | 'itemHeight', number>) => {\n    if (typeof _padding !== 'number' && !isObject(_padding)) {\n        throw new Error('Invalid property padding, must be one of: number, object')\n    }\n\n    const padding =\n        typeof _padding === 'number'\n            ? {\n                  top: _padding,\n                  right: _padding,\n                  bottom: _padding,\n                  left: _padding,\n              }\n            : {\n                  ...zeroPadding,\n                  ..._padding,\n              }\n\n    const horizontalPadding = padding.left + padding.right\n    const verticalPadding = padding.top + padding.bottom\n    let width = itemWidth + horizontalPadding\n    let height = itemHeight + verticalPadding\n    const spacing = (itemCount - 1) * itemsSpacing\n    if (direction === 'row') {\n        width = itemWidth * itemCount + spacing + horizontalPadding\n    } else if (direction === 'column') {\n        height = itemHeight * itemCount + spacing + verticalPadding\n    }\n\n    return { width, height, padding }\n}\n\nexport const computePositionFromAnchor = ({\n    anchor,\n    translateX,\n    translateY,\n    containerWidth,\n    containerHeight,\n    width,\n    height,\n}: { anchor: LegendAnchor } & Record<\n    'translateX' | 'translateY' | 'containerWidth' | 'containerHeight' | 'width' | 'height',\n    number\n>) => {\n    let x = translateX\n    let y = translateY\n\n    switch (anchor) {\n        case 'top':\n            x += (containerWidth - width) / 2\n            break\n\n        case 'top-right':\n            x += containerWidth - width\n            break\n\n        case 'right':\n            x += containerWidth - width\n            y += (containerHeight - height) / 2\n            break\n\n        case 'bottom-right':\n            x += containerWidth - width\n            y += containerHeight - height\n            break\n\n        case 'bottom':\n            x += (containerWidth - width) / 2\n            y += containerHeight - height\n            break\n\n        case 'bottom-left':\n            y += containerHeight - height\n            break\n\n        case 'left':\n            y += (containerHeight - height) / 2\n            break\n\n        case 'center':\n            x += (containerWidth - width) / 2\n            y += (containerHeight - height) / 2\n            break\n    }\n\n    return { x, y }\n}\n\nexport const computeItemLayout = ({\n    direction,\n    justify,\n    symbolSize,\n    symbolSpacing,\n    width,\n    height,\n}: {\n    direction: LegendItemDirection\n    justify: boolean\n} & Record<'symbolSize' | 'symbolSpacing' | 'width' | 'height', number>) => {\n    let symbolX\n    let symbolY\n\n    let labelX\n    let labelY\n    let labelAnchor: 'start' | 'middle' | 'end'\n    let labelAlignment: 'alphabetic' | 'central' | 'text-before-edge'\n\n    switch (direction) {\n        case 'left-to-right':\n            symbolX = 0\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = width\n                labelAnchor = 'end'\n            } else {\n                labelX = symbolSize + symbolSpacing\n                labelAnchor = 'start'\n            }\n            break\n\n        case 'right-to-left':\n            symbolX = width - symbolSize\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = 0\n                labelAnchor = 'start'\n            } else {\n                labelX = width - symbolSize - symbolSpacing\n                labelAnchor = 'end'\n            }\n            break\n\n        case 'top-to-bottom':\n            symbolX = (width - symbolSize) / 2\n            symbolY = 0\n\n            labelX = width / 2\n\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = height\n                labelAlignment = 'alphabetic'\n            } else {\n                labelY = symbolSize + symbolSpacing\n                labelAlignment = 'text-before-edge'\n            }\n            break\n\n        case 'bottom-to-top':\n            symbolX = (width - symbolSize) / 2\n            symbolY = height - symbolSize\n\n            labelX = width / 2\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = 0\n                labelAlignment = 'text-before-edge'\n            } else {\n                labelY = height - symbolSize - symbolSpacing\n                labelAlignment = 'alphabetic'\n            }\n            break\n    }\n\n    return {\n        symbolX,\n        symbolY,\n        labelX,\n        labelY,\n        labelAnchor,\n        labelAlignment,\n    }\n}\n\nexport const computeContinuousColorsLegend = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    // left to right for `row`, bottom to top for `column`\n    const domain = direction === 'column' ? [...scale.domain()].reverse() : scale.domain()\n\n    const positionScale = scaleLinear().domain(domain)\n    if (domain.length === 2) {\n        // sequential, quantize\n        positionScale.range([0, length])\n    } else if (domain.length === 3) {\n        // diverging\n        positionScale.range([0, length / 2, length])\n    }\n\n    let values: number[]\n    if ('thresholds' in scale) {\n        // quantize\n        values = [domain[0], ...scale.thresholds(), domain[1]]\n    } else {\n        // sequential, diverging\n        values = Array.isArray(ticks) ? ticks : (scale as any).ticks(ticks)\n    }\n\n    const colorStops = computeContinuousColorScaleColorStops(scale, 32)\n\n    const formatValue = getValueFormatter(tickFormat)\n\n    const computedTicks: {\n        x1: number\n        y1: number\n        x2: number\n        y2: number\n        text: string\n        textX: number\n        textY: number\n        textHorizontalAlign: 'start' | 'middle' | 'end'\n        textVerticalAlign: 'alphabetic' | 'central' | 'hanging'\n    }[] = []\n\n    let width: number\n    let height: number\n\n    const gradientX1 = 0\n    let gradientY1 = 0\n    let gradientX2 = 0\n    const gradientY2 = 0\n\n    let titleX: number\n    let titleY: number\n    let titleRotation: number\n    let titleVerticalAlign: 'alphabetic' | 'hanging'\n\n    if (direction === 'row') {\n        width = length\n        height = thickness\n\n        gradientX2 = 1\n\n        let y1: number\n        let y2: number\n\n        let textY: number\n        const textHorizontalAlign = 'middle'\n        let textVerticalAlign: 'alphabetic' | 'hanging'\n\n        titleRotation = 0\n        if (titleAlign === 'start') {\n            titleX = 0\n        } else if (titleAlign === 'middle') {\n            titleX = length / 2\n        } else {\n            titleX = length\n        }\n\n        if (tickPosition === 'before') {\n            y1 = -tickSize\n            y2 = tickOverlap ? thickness : 0\n\n            textY = -tickSize - tickSpacing\n            textVerticalAlign = 'alphabetic'\n\n            titleY = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            y1 = tickOverlap ? 0 : thickness\n            y2 = thickness + tickSize\n\n            textY = y2 + tickSpacing\n            textVerticalAlign = 'hanging'\n\n            titleY = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const x = positionScale(value)\n\n            computedTicks.push({\n                x1: x,\n                y1,\n                x2: x,\n                y2,\n                text: formatValue(value),\n                textX: x,\n                textY,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    } else {\n        width = thickness\n        height = length\n\n        gradientY1 = 1\n\n        let x1: number\n        let x2: number\n\n        let textX: number\n        let textHorizontalAlign: 'start' | 'end'\n        const textVerticalAlign = 'central'\n\n        titleRotation = -90\n        if (titleAlign === 'start') {\n            titleY = length\n        } else if (titleAlign === 'middle') {\n            titleY = length / 2\n        } else {\n            titleY = 0\n        }\n\n        if (tickPosition === 'before') {\n            x1 = -tickSize\n            x2 = tickOverlap ? thickness : 0\n\n            textX = x1 - tickSpacing\n            textHorizontalAlign = 'end'\n\n            titleX = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            x1 = tickOverlap ? 0 : thickness\n            x2 = thickness + tickSize\n\n            textX = x2 + tickSpacing\n            textHorizontalAlign = 'start'\n\n            titleX = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const y = positionScale(value)\n\n            computedTicks.push({\n                x1,\n                y1: y,\n                x2,\n                y2: y,\n                text: formatValue(value),\n                textX,\n                textY: y,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    }\n\n    return {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks: computedTicks,\n        titleText: title,\n        titleX,\n        titleY,\n        titleRotation,\n        titleHorizontalAlign: titleAlign,\n        titleVerticalAlign,\n    }\n}\n", "import { Fragment } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { computeContinuousColorsLegend } from '../compute'\nimport { ContinuousColorsLegendProps } from '../types'\nimport { continuousColorsLegendDefaults } from '../defaults'\n\nexport const ContinuousColorsLegendSvg = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        ticks: computedTicks,\n        colorStops,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const theme = useTheme()\n\n    const id = `ContinuousColorsLegendSvgGradient.${direction}.${colorStops\n        .map(stop => stop.offset)\n        .join('_')}`\n\n    return (\n        <g>\n            <defs>\n                <linearGradient\n                    id={id}\n                    x1={gradientX1}\n                    y1={gradientY1}\n                    x2={gradientX2}\n                    y2={gradientY2}\n                >\n                    {colorStops.map(colorStop => (\n                        <stop {...colorStop} />\n                    ))}\n                </linearGradient>\n            </defs>\n            {titleText && (\n                <text\n                    transform={`translate(${titleX}, ${titleY}) rotate(${titleRotation})`}\n                    textAnchor={titleHorizontalAlign}\n                    dominantBaseline={titleVerticalAlign}\n                    style={theme.legends.title.text}\n                >\n                    {titleText}\n                </text>\n            )}\n            <rect width={width} height={height} fill={`url(#${id}`} />\n            {computedTicks.map((tick, index) => (\n                <Fragment key={index}>\n                    <line\n                        x1={tick.x1}\n                        y1={tick.y1}\n                        x2={tick.x2}\n                        y2={tick.y2}\n                        style={theme.legends.ticks.line}\n                    />\n                    <text\n                        x={tick.textX}\n                        y={tick.textY}\n                        textAnchor={tick.textHorizontalAlign}\n                        dominantBaseline={tick.textVerticalAlign}\n                        style={theme.legends.ticks.text}\n                    >\n                        {tick.text}\n                    </text>\n                </Fragment>\n            ))}\n        </g>\n    )\n}\n", "import { AnchoredContinuousColorsLegendProps } from '../types'\nimport { computePositionFromAnchor } from '../compute'\nimport { continuousColorsLegendDefaults } from '../defaults'\nimport { ContinuousColorsLegendSvg } from './ContinuousColorsLegendSvg'\n\nexport const AnchoredContinuousColorsLegendSvg = ({\n    containerWidth,\n    containerHeight,\n    anchor,\n    translateX = 0,\n    translateY = 0,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    ...legendProps\n}: AnchoredContinuousColorsLegendProps) => {\n    let width: number\n    let height: number\n    if (direction === 'row') {\n        width = length\n        height = thickness\n    } else {\n        width = thickness\n        height = length\n    }\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <g transform={`translate(${x}, ${y})`}>\n            <ContinuousColorsLegendSvg\n                length={length}\n                thickness={thickness}\n                direction={direction}\n                {...legendProps}\n            />\n        </g>\n    )\n}\n", "import { useState, useCallback } from 'react'\nimport * as React from 'react'\nimport { useTheme, sanitizeSvgTextStyle } from '@nivo/core'\nimport { LegendSvgItemProps } from '../types'\nimport { computeItemLayout } from '../compute'\nimport { SymbolCircle, SymbolDiamond, SymbolSquare, SymbolTriangle } from './symbols'\n\ntype Style = Partial<{\n    itemBackground: string\n    itemOpacity: number\n    itemTextColor: string\n    symbolBorderColor: string\n    symbolBorderWidth: number\n    symbolSize: number\n}>\n\nconst symbolByShape = {\n    circle: SymbolCircle,\n    diamond: SymbolDiamond,\n    square: SymbolSquare,\n    triangle: SymbolTriangle,\n}\n\nexport const LegendSvgItem = ({\n    x,\n    y,\n    width,\n    height,\n    data,\n    direction = 'left-to-right',\n    justify = false,\n    textColor,\n    background = 'transparent',\n    opacity = 1,\n\n    symbolShape = 'square',\n    symbolSize = 16,\n    symbolSpacing = 8,\n    symbolBorderWidth = 0,\n    symbolBorderColor = 'transparent',\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: LegendSvgItemProps) => {\n    const [style, setStyle] = useState<Style>({})\n    const theme = useTheme()\n\n    const handleMouseEnter = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on === 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseEnter?.(data, event)\n        },\n        [onMouseEnter, data, effects]\n    )\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on !== 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseLeave?.(data, event)\n        },\n        [onMouseLeave, data, effects]\n    )\n\n    const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout({\n        direction,\n        justify,\n        symbolSize: style.symbolSize ?? symbolSize,\n        symbolSpacing,\n        width,\n        height,\n    })\n\n    const isInteractive = [onClick, onMouseEnter, onMouseLeave, toggleSerie].some(\n        handler => handler !== undefined\n    )\n\n    const SymbolShape = typeof symbolShape === 'function' ? symbolShape : symbolByShape[symbolShape]\n\n    return (\n        <g\n            transform={`translate(${x},${y})`}\n            style={{\n                opacity: style.itemOpacity ?? opacity,\n            }}\n        >\n            <rect\n                width={width}\n                height={height}\n                fill={style.itemBackground ?? background}\n                style={{\n                    cursor: isInteractive ? 'pointer' : 'auto',\n                }}\n                onClick={event => {\n                    onClick?.(data, event)\n                    toggleSerie?.(data.id)\n                }}\n                onMouseEnter={handleMouseEnter}\n                onMouseLeave={handleMouseLeave}\n            />\n            {React.createElement(SymbolShape, {\n                id: data.id,\n                x: symbolX,\n                y: symbolY,\n                size: style.symbolSize ?? symbolSize,\n                fill: data.fill ?? data.color ?? 'black',\n                borderWidth: style.symbolBorderWidth ?? symbolBorderWidth,\n                borderColor: style.symbolBorderColor ?? symbolBorderColor,\n                ...(data.hidden ? theme.legends.hidden.symbol : undefined),\n            })}\n            <text\n                textAnchor={labelAnchor}\n                style={{\n                    ...sanitizeSvgTextStyle(theme.legends.text),\n                    fill: style.itemTextColor ?? textColor ?? theme.legends.text.fill ?? 'black',\n                    dominantBaseline: labelAlignment,\n                    pointerEvents: 'none',\n                    userSelect: 'none',\n                    ...(data.hidden ? theme.legends.hidden.text : undefined),\n                }}\n                x={labelX}\n                y={labelY}\n            >\n                {data.label}\n            </text>\n        </g>\n    )\n}\n", "import { LegendSvgItem } from './LegendSvgItem'\nimport { LegendSvgProps } from '../types'\nimport { computeDimensions } from '../compute'\n\nexport const LegendSvg = ({\n    data,\n\n    x,\n    y,\n    direction,\n    padding: _padding = 0,\n    justify,\n    effects,\n\n    itemWidth,\n    itemHeight,\n    itemDirection = 'left-to-right',\n    itemsSpacing = 0,\n    itemTextColor,\n    itemBackground = 'transparent',\n    itemOpacity = 1,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n}: LegendSvgProps) => {\n    const { padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    return (\n        <g transform={`translate(${x},${y})`}>\n            {data.map((data, i) => (\n                <LegendSvgItem\n                    key={i}\n                    data={data}\n                    x={i * xStep + padding.left}\n                    y={i * yStep + padding.top}\n                    width={itemWidth}\n                    height={itemHeight}\n                    direction={itemDirection}\n                    justify={justify}\n                    effects={effects}\n                    textColor={itemTextColor}\n                    background={itemBackground}\n                    opacity={itemOpacity}\n                    symbolShape={symbolShape}\n                    symbolSize={symbolSize}\n                    symbolSpacing={symbolSpacing}\n                    symbolBorderWidth={symbolBorderWidth}\n                    symbolBorderColor={symbolBorderColor}\n                    onClick={onClick}\n                    onMouseEnter={onMouseEnter}\n                    onMouseLeave={onMouseLeave}\n                    toggleSerie={toggleSerie}\n                />\n            ))}\n        </g>\n    )\n}\n", "import { LegendSvg } from './LegendSvg'\nimport { BoxLegendSvgProps } from '../types'\nimport { computeDimensions, computePositionFromAnchor } from '../compute'\n\nexport const BoxLegendSvg = ({\n    data,\n\n    containerWidth,\n    containerHeight,\n    translateX = 0,\n    translateY = 0,\n    anchor,\n    direction,\n    padding = 0,\n    justify,\n\n    itemsSpacing = 0,\n    itemWidth,\n    itemHeight,\n    itemDirection,\n    itemTextColor,\n    itemBackground,\n    itemOpacity,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: BoxLegendSvgProps) => {\n    const { width, height } = computeDimensions({\n        itemCount: data.length,\n        itemsSpacing,\n        itemWidth,\n        itemHeight,\n        direction,\n        padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <LegendSvg\n            data={data}\n            x={x}\n            y={y}\n            direction={direction}\n            padding={padding}\n            justify={justify}\n            effects={effects}\n            itemsSpacing={itemsSpacing}\n            itemWidth={itemWidth}\n            itemHeight={itemHeight}\n            itemDirection={itemDirection}\n            itemTextColor={itemTextColor}\n            itemBackground={itemBackground}\n            itemOpacity={itemOpacity}\n            symbolShape={symbolShape}\n            symbolSize={symbolSize}\n            symbolSpacing={symbolSpacing}\n            symbolBorderWidth={symbolBorderWidth}\n            symbolBorderColor={symbolBorderColor}\n            onClick={onClick}\n            onMouseEnter={onMouseEnter}\n            onMouseLeave={onMouseLeave}\n            toggleSerie={typeof toggleSerie === 'boolean' ? undefined : toggleSerie}\n        />\n    )\n}\n", "import { CompleteTheme, degreesToRadians } from '@nivo/core'\nimport {\n    computeDimensions,\n    computePositionFromAnchor,\n    computeItemLayout,\n    computeContinuousColorsLegend,\n} from './compute'\nimport { AnchoredContinuousColorsLegendProps, LegendCanvasProps } from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst textAlignMapping = {\n    start: 'left',\n    middle: 'center',\n    end: 'right',\n} as const\n\nexport const renderLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        data,\n\n        containerWidth,\n        containerHeight,\n        translateX = 0,\n        translateY = 0,\n        anchor,\n        direction,\n        padding: _padding = 0,\n        justify = false,\n\n        // items\n        itemsSpacing = 0,\n        itemWidth,\n        itemHeight,\n        itemDirection = 'left-to-right',\n        itemTextColor,\n\n        // symbol\n        symbolSize = 16,\n        symbolSpacing = 8,\n        // @todo add support for shapes\n        // symbolShape = LegendSvgItem.defaultProps.symbolShape,\n\n        theme,\n    }: LegendCanvasProps\n) => {\n    const { width, height, padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.font = `${theme.legends.text.fontSize}px ${theme.legends.text.fontFamily || 'sans-serif'}`\n\n    data.forEach((d, i) => {\n        const itemX = i * xStep + padding.left\n        const itemY = i * yStep + padding.top\n\n        const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout(\n            {\n                direction: itemDirection,\n                justify,\n                symbolSize,\n                symbolSpacing,\n                width: itemWidth,\n                height: itemHeight,\n            }\n        )\n\n        ctx.fillStyle = d.color ?? 'black'\n        ctx.fillRect(itemX + symbolX, itemY + symbolY, symbolSize, symbolSize)\n\n        ctx.textAlign = textAlignMapping[labelAnchor]\n\n        if (labelAlignment === 'central') {\n            ctx.textBaseline = 'middle'\n        }\n\n        ctx.fillStyle = itemTextColor ?? theme.legends.text.fill ?? 'black'\n        ctx.fillText(String(d.label), itemX + labelX, itemY + labelY)\n    })\n\n    ctx.restore()\n}\n\nexport const renderContinuousColorLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        containerWidth,\n        containerHeight,\n        anchor,\n        translateX = 0,\n        translateY = 0,\n        scale,\n        length = continuousColorsLegendDefaults.length,\n        thickness = continuousColorsLegendDefaults.thickness,\n        direction = continuousColorsLegendDefaults.direction,\n        ticks: _ticks,\n        tickPosition = continuousColorsLegendDefaults.tickPosition,\n        tickSize = continuousColorsLegendDefaults.tickSize,\n        tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n        tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n        tickFormat = continuousColorsLegendDefaults.tickFormat,\n        title,\n        titleAlign = continuousColorsLegendDefaults.titleAlign,\n        titleOffset = continuousColorsLegendDefaults.titleOffset,\n        theme,\n    }: AnchoredContinuousColorsLegendProps & {\n        theme: CompleteTheme\n    }\n) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks: _ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const initialStyles = {\n        font: ctx.font,\n        textAlign: ctx.textAlign,\n        textBaseline: ctx.textBaseline,\n    }\n    ctx.save()\n\n    ctx.translate(x, y)\n\n    const gradient = ctx.createLinearGradient(\n        gradientX1 * width,\n        gradientY1 * height,\n        gradientX2 * width,\n        gradientY2 * height\n    )\n    colorStops.forEach(colorStop => {\n        gradient.addColorStop(colorStop.offset, colorStop.stopColor)\n    })\n\n    ctx.fillStyle = gradient\n    ctx.fillRect(0, 0, width, height)\n\n    ctx.font = `${\n        theme.legends.ticks.text.fontWeight ? `${theme.legends.ticks.text.fontWeight} ` : ''\n    }${theme.legends.ticks.text.fontSize}px ${theme.legends.ticks.text.fontFamily}`\n\n    ticks.forEach(tick => {\n        if ((theme.legends.ticks.line.strokeWidth ?? 0) > 0) {\n            ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth)\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n            ctx.lineCap = 'square'\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x1, tick.y1)\n            ctx.lineTo(tick.x2, tick.y2)\n            ctx.stroke()\n        }\n\n        if (theme.legends.ticks.text.fill) {\n            ctx.fillStyle = theme.legends.ticks.text.fill\n        }\n        ctx.textAlign = tick.textHorizontalAlign === 'middle' ? 'center' : tick.textHorizontalAlign\n        ctx.textBaseline = tick.textVerticalAlign === 'central' ? 'middle' : tick.textVerticalAlign\n\n        ctx.fillText(tick.text, tick.textX, tick.textY)\n    })\n\n    if (titleText) {\n        ctx.save()\n        ctx.translate(titleX, titleY)\n        ctx.rotate(degreesToRadians(titleRotation))\n\n        ctx.font = `${\n            theme.legends.title.text.fontWeight ? `${theme.legends.title.text.fontWeight} ` : ''\n        }${theme.legends.title.text.fontSize}px ${theme.legends.title.text.fontFamily}`\n        if (theme.legends.title.text.fill) {\n            ctx.fillStyle = theme.legends.title.text.fill\n        }\n        ctx.textAlign = titleHorizontalAlign === 'middle' ? 'center' : titleHorizontalAlign\n        ctx.textBaseline = titleVerticalAlign\n\n        ctx.fillText(titleText, 0, 0)\n\n        ctx.restore()\n    }\n\n    ctx.restore()\n\n    ctx.font = initialStyles.font\n    ctx.textAlign = initialStyles.textAlign\n    ctx.textBaseline = initialStyles.textBaseline\n}\n", "import { useMemo } from 'react'\n\ntype Scale = {\n    (value: number): number\n    invertExtent: (value: number) => [number, number]\n    range: () => number[]\n}\n\nexport const useQuantizeColorScaleLegendData = ({\n    scale,\n    domain: overriddenDomain,\n    reverse = false,\n    valueFormat = v => v,\n    separator = ' - ',\n}: {\n    scale: Scale\n    domain?: number[]\n    reverse?: boolean\n    valueFormat?: <T, U>(value: T) => T | U\n    separator?: string\n}) => {\n    return useMemo(() => {\n        const domain = overriddenDomain ?? scale.range()\n\n        const items = domain.map((domainValue, index) => {\n            const [start, end] = scale.invertExtent(domainValue)\n\n            return {\n                id: domainValue,\n                index,\n                extent: [start, end],\n                label: `${valueFormat(start)}${separator}${valueFormat(end)}`,\n                value: scale(start),\n                color: domainValue,\n            }\n        })\n\n        if (reverse) items.reverse()\n\n        return items\n    }, [overriddenDomain, scale, reverse, separator, valueFormat])\n}\n"],
  "mappings": "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",
  "names": ["SymbolCircle", "_ref", "x", "y", "size", "fill", "_ref$opacity", "opacity", "_ref$borderWidth", "borderWidth", "_ref$borderColor", "borderColor", "_jsx", "r", "cx", "cy", "strokeWidth", "stroke", "style", "pointerEvents", "SymbolDiamond", "transform", "children", "d", "SymbolSquare", "width", "height", "SymbolTriangle", "t", "e", "continuousColorsLegendDefaults", "length", "thickness", "direction", "tickPosition", "tickSize", "tickSpacing", "tickOverlap", "tickFormat", "value", "titleAlign", "titleOffset", "zeroPadding", "top", "right", "bottom", "left", "computeDimensions", "item", "itemsSpacing", "_padding", "padding", "itemCount", "itemWidth", "itemHeight", "Array", "isArray", "Error", "_extends", "horizontalPadding", "verticalPadding", "spacing", "computePositionFromAnchor", "_ref2", "anchor", "translateX", "translateY", "containerWidth", "containerHeight", "computeItemLayout", "_ref3", "symbolX", "symbolY", "labelX", "labelY", "labelAnchor", "labelAlignment", "justify", "symbolSize", "symbolSpacing", "computeContinuousColorsLegend", "_ref4", "values", "scale", "ticks", "_ref4$length", "_ref4$thickness", "_ref4$direction", "_ref4$tickPosition", "_ref4$tickSize", "_ref4$tickSpacing", "_ref4$tickOverlap", "_ref4$tickFormat", "title", "_ref4$titleAlign", "_ref4$titleOffset", "domain", "concat", "reverse", "positionScale", "scaleLinear", "range", "thresholds", "titleX", "titleY", "titleRotation", "titleVerticalAlign", "colorStops", "computeContinuousColorScaleColorStops", "formatValue", "getValueFormatter", "computedTicks", "gradientY1", "gradientX2", "y1", "y2", "textY", "textVerticalAlign", "forEach", "push", "x1", "x2", "text", "textX", "textHorizontalAlign", "gradientX1", "gradientY2", "titleText", "titleHorizontalAlign", "ContinuousColorsLegendSvg", "_ref$length", "_ref$thickness", "_ref$direction", "_ref$tickPosition", "_ref$tickSize", "_ref$tickSpacing", "_ref$tickOverlap", "_ref$tickFormat", "_ref$titleAlign", "_ref$titleOffset", "_computeContinuousCol", "theme", "useTheme", "id", "map", "stop", "offset", "join", "_jsxs", "colorStop", "textAnchor", "dominantBaseline", "legends", "tick", "index", "Fragment", "line", "AnchoredContinuousColorsLegendSvg", "_ref$translateX", "_ref$translateY", "legendProps", "_excluded", "_computePositionFromA", "symbolByShape", "circle", "diamond", "square", "triangle", "LegendSvgItem", "_style$symbolSize", "_style$itemOpacity", "_style$itemBackground", "_style$symbolSize2", "_data$fill", "_style$symbolBorderWi", "_style$symbolBorderCo", "_ref5", "_ref6", "_style$itemTextColor", "data", "_ref$justify", "textColor", "_ref$background", "background", "_ref$symbolShape", "symbolShape", "_ref$symbolSize", "_ref$symbolSpacing", "_ref$symbolBorderWidt", "symbolBorderWidth", "_ref$symbolBorderColo", "symbolBorderColor", "onClick", "onMouseEnter", "onMouseLeave", "toggleSerie", "effects", "_useState", "useState", "setStyle", "handleMouseEnter", "useCallback", "event", "filter", "on", "reduce", "acc", "effect", "handleMouseLeave", "_computeItemLayout", "isInteractive", "some", "handler", "SymbolShape", "itemOpacity", "itemBackground", "cursor", "createElement", "color", "hidden", "symbol", "undefined", "sanitizeSvgTextStyle", "itemTextColor", "userSelect", "label", "LegendSvg", "_ref$padding", "_ref$itemDirection", "itemDirection", "_ref$itemsSpacing", "_ref$itemBackground", "_ref$itemOpacity", "xStep", "yStep", "i", "BoxLegendSvg", "_computeDimensions", "textAlignMapping", "start", "middle", "end", "renderLegendToCanvas", "ctx", "save", "translate", "font", "fontSize", "fontFamily", "_d$color", "itemX", "itemY", "fillStyle", "fillRect", "textAlign", "textBaseline", "fillText", "String", "restore", "renderContinuousColorLegendToCanvas", "_ref3$translateX", "_ref3$translateY", "_ref3$length", "_ref3$thickness", "_ref3$direction", "_ticks", "_ref3$tickPosition", "_ref3$tickSize", "_ref3$tickSpacing", "_ref3$tickOverlap", "_ref3$tickFormat", "_ref3$titleAlign", "_ref3$titleOffset", "_computePositionFromA2", "initialStyles", "gradient", "createLinearGradient", "addColorStop", "stopColor", "fontWeight", "_theme$legends$ticks$", "lineWidth", "Number", "axis", "strokeStyle", "lineCap", "beginPath", "moveTo", "lineTo", "rotate", "degreesToRadians", "useQuantizeColorScaleLegendData", "overriddenDomain", "_ref$reverse", "_ref$valueFormat", "valueFormat", "v", "_ref$separator", "separator", "useMemo", "items", "domainValue", "_scale$invertExtent", "invertExtent", "extent"]
}
